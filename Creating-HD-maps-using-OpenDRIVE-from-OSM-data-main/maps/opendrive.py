#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Nov  2 10:14:54 2023 by generateDS.py version 2.43.2.
# Python 3.11.6 (tags/v3.11.6:8b6ee5b, Oct  2 2023, 14:57:12) [MSC v.1935 64 bit (AMD64)]
#
# Command line options:
#   ('--use-getter-setter', 'none')
#   ('-o', 'C:\\Abdelmawla\\GitHub\\ATMOS-Scenery_Model-Generator\\ASAM_OpenDRIVE_BS_V1_7_0\\opendrive_17.py')
#
# Command line arguments:
#   C:\Abdelmawla\GitHub\ATMOS-Scenery_Model-Generator\ASAM_OpenDRIVE_BS_V1_7_0\xsd_schema\opendrive_17_core.xsd
#
# Command line:
#   C:\Users\abdelmaw\AppData\Local\Programs\Python\Python311\Scripts\generateDS.py --use-getter-setter="none" -o "C:\Abdelmawla\GitHub\ATMOS-Scenery_Model-Generator\ASAM_OpenDRIVE_BS_V1_7_0\opendrive_17.py" C:\Abdelmawla\GitHub\ATMOS-Scenery_Model-Generator\ASAM_OpenDRIVE_BS_V1_7_0\xsd_schema\opendrive_17_core.xsd
#
# Current working directory (os.getcwd()):
#   Abdelmawla
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_
import lxml as lxml

Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""

BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

GenerateDSNamespaceDefs_ = {}
GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
# try:
#     from generatedscollector import GdsCollector as GdsCollector_
# except ModulenotfoundExp_ :

class GdsCollector_(object):

    def __init__(self, messages=None):
        if messages is None:
            self.messages = []
        else:
            self.messages = messages

    def add_message(self, msg):
        self.messages.append(msg)

    def get_messages(self):
        return self.messages

    def clear_messages(self):
        self.messages = []

    def print_messages(self):
        for msg in self.messages:
            print("Warning: {}".format(msg))

    def write_messages(self, outstream):
        for msg in self.messages:
            outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            value = ('%.15f' % float(input_data)).rstrip('0')
            if value.endswith('.'):
                value += '0'
            return value
    
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, lxml.etree.CDATA):
                
                result = lxml.ElementTree.tostring( instring, encoding="utf8")
            
            elif isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Start enum classes
#
class e_accessRestrictionType(str, Enum):
    SIMULATOR='simulator'
    AUTONOMOUS_TRAFFIC='autonomousTraffic'
    PEDESTRIAN='pedestrian'
    PASSENGER_CAR='passengerCar'
    BUS='bus'
    DELIVERY='delivery'
    EMERGENCY='emergency'
    TAXI='taxi'
    THROUGH_TRAFFIC='throughTraffic'
    TRUCK='truck'
    BICYCLE='bicycle'
    MOTORCYCLE='motorcycle'
    NONE='none'
    TRUCKS='trucks'


class e_borderType(str, Enum):
    CONCRETE='concrete'
    CURB='curb'


class e_bridgeType(str, Enum):
    CONCRETE='concrete'
    STEEL='steel'
    BRICK='brick'
    WOOD='wood'


class e_connection_type(str, Enum):
    DEFAULT='default'
    VIRTUAL='virtual'


class e_contactPoint(str, Enum):
    START='start'
    END='end'


class e_countryCode_deprecated(str, Enum):
    OPEN_DRIVE='OpenDRIVE'
    AUSTRIA='Austria'
    BRAZIL='Brazil'
    CHINA='China'
    FRANCE='France'
    GERMANY='Germany'
    ITALY='Italy'
    SWITZERLAND='Switzerland'
    USA='USA'


class e_dataQuality_RawData_PostProcessing(str, Enum):
    RAW='raw'
    CLEANED='cleaned'
    PROCESSED='processed'
    FUSED='fused'


class e_dataQuality_RawData_PostProcessing10(str, Enum):
    RAW='raw'
    CLEANED='cleaned'
    PROCESSED='processed'
    FUSED='fused'


class e_dataQuality_RawData_Source(str, Enum):
    SENSOR='sensor'
    CADASTER='cadaster'
    CUSTOM='custom'


class e_dataQuality_RawData_Source11(str, Enum):
    SENSOR='sensor'
    CADASTER='cadaster'
    CUSTOM='custom'


class e_direction(str, Enum):
    SAME='same'
    OPPOSITE='opposite'


class e_elementDir(str, Enum):
    _='+'
    __1='-'


class e_junctionGroup_type(str, Enum):
    ROUNDABOUT='roundabout'
    UNKNOWN='unknown'


class e_junction_surface_CRG_mode(str, Enum):
    GLOBAL='global'


class e_junction_type(str, Enum):
    DEFAULT='default'
    VIRTUAL='virtual'
    DIRECT='direct'


class e_laneType(str, Enum):
    """e_laneType -- The lane type is defined per lane. A lane type defines the main purpose of a lane and its corresponding traffic rules.
    
    """
    SHOULDER='shoulder' # Describes a soft shoulder at the edge of the road
    BORDER='border' # Describes a hard border at the edge of the road. has the same height as the drivable lane.
    DRIVING='driving' # “normal” drivable road, which is not one of the other types
    STOP='stop' # Hard shoulder on motorways for emergency stops
    NONE='none' # "Invisible" lane. This lane is on the most ouside of the road. Its only purpose is for simulation, that there is still opendrive present in case the (human) driver leaves the road.
    RESTRICTED='restricted' # Lane on which cars should not drive, but have the same height as the drivable lanes. Typically they are separated with lines and often there are additional striped lines on them.
    PARKING='parking' # Lane with parking spaces
    MEDIAN='median' # Lane between driving lanes in oposite directions. Typically used in towns on large roads, to separate the traffic.
    BIKING='biking' # Lane reserved for Cyclists
    SIDEWALK='sidewalk' # Lane on which pedestrians can walk savely
    CURB='curb' # Lane "curb" is used for curbstones. These have a different height compared to the drivable lanes.
    EXIT='exit' # Lane Type „exit“ is used for the sections which is parallel to the main road (meaning deceleration lanes)
    ENTRY='entry' # Lane Type „entry“ is used for the sections which is parallel to the main road (meaning acceleration lanes
    ON_RAMP='onRamp' # A ramp leading to a motorway from rural/urban roads is an „onRamp“.
    OFF_RAMP='offRamp' # A ramp leading away from a motorway and onto rural/urban roads is an „offRamp”.
    CONNECTING_RAMP='connectingRamp' # A ramp connecting two motorways is a „connectingRamp“ (e.g. motorway junction)
    BIDIRECTIONAL='bidirectional' # this lane type has two use cases: a) only driving lane on a narrow road which may be used in both directions; b) continuous two-way left turn lane on multi-lane roads – US road networks
    SPECIAL_1='special1'
    SPECIAL_2='special2'
    SPECIAL_3='special3'
    ROAD_WORKS='roadWorks'
    TRAM='tram'
    RAIL='rail'
    BUS='bus'
    TAXI='taxi'
    HOV='HOV' # high-occupancy vehicle / carpool vehicle
    MWY_ENTRY='mwyEntry' # entry (deprecated)
    MWY_EXIT='mwyExit' # exit (deprecated)


class e_maxSpeedString(str, Enum):
    NOLIMIT='no limit'
    UNDEFINED='undefined'


class e_objectType(str, Enum):
    NONE='none' # i.e. unknown
    OBSTACLE='obstacle' # for anything that is not further categorized
    CAR='car' # deprecated
    POLE='pole'
    TREE='tree'
    VEGETATION='vegetation'
    BARRIER='barrier'
    BUILDING='building'
    PARKING_SPACE='parkingSpace'
    PATCH='patch'
    RAILING='railing'
    TRAFFIC_ISLAND='trafficIsland'
    CROSSWALK='crosswalk'
    STREET_LAMP='streetLamp'
    GANTRY='gantry'
    SOUND_BARRIER='soundBarrier'
    VAN='van' # deprecated
    BUS='bus' # deprecated
    TRAILER='trailer' # deprecated
    BIKE='bike' # deprecated
    MOTORBIKE='motorbike' # deprecated
    TRAM='tram' # deprecated
    TRAIN='train' # deprecated
    PEDESTRIAN='pedestrian' # deprecated
    WIND='wind' # deprecated
    ROAD_MARK='roadMark'


class e_orientation(str, Enum):
    _='+'
    __1='-'
    NONE='none'


class e_outlineFillType(str, Enum):
    GRASS='grass'
    CONCRETE='concrete'
    COBBLE='cobble'
    ASPHALT='asphalt'
    PAVEMENT='pavement'
    GRAVEL='gravel'
    SOIL='soil'


class e_paramPoly3_pRange(str, Enum):
    ARC_LENGTH='arcLength'
    NORMALIZED='normalized'


class e_roadMarkColor(str, Enum):
    """e_roadMarkColor -- The known keywords for the road mark color information are:
    
    """
    STANDARD='standard' # equivalent to "white"
    BLUE='blue'
    GREEN='green'
    RED='red'
    WHITE='white'
    YELLOW='yellow'
    ORANGE='orange'
    VIOLET='violet'


class e_roadMarkRule(str, Enum):
    NOPASSING='no passing'
    CAUTION='caution'
    NONE='none'


class e_roadMarkType(str, Enum):
    """e_roadMarkType -- The known keywords for the simplified road mark type information are:
    
    """
    NONE='none'
    SOLID='solid'
    BROKEN='broken'
    SOLIDSOLID='solid solid' # for double solid line
    SOLIDBROKEN='solid broken' # from inside to outside, exception: center lane – from left to right
    BROKENSOLID='broken solid' # from inside to outside, exception: center lane – from left to right
    BROKENBROKEN='broken broken' # from inside to outside, exception: center lane – from left to right
    BOTTSDOTS='botts dots'
    GRASS='grass' # meaning a grass edge
    CURB='curb'
    CUSTOM='custom' # if detailed description is given in child tags
    EDGE='edge' # describing the limit of usable space on a road


class e_roadMarkWeight(str, Enum):
    STANDARD='standard'
    BOLD='bold'


class e_roadType(str, Enum):
    """e_roadType -- The known keywords for the road type information are:
    
    """
    UNKNOWN='unknown'
    RURAL='rural'
    MOTORWAY='motorway'
    TOWN='town'
    LOW_SPEED='lowSpeed' # In Germany, lowSpeed is equivalent to a 30km/h zone
    PEDESTRIAN='pedestrian'
    BICYCLE='bicycle'
    TOWN_EXPRESSWAY='townExpressway'
    TOWN_COLLECTOR='townCollector'
    TOWN_ARTERIAL='townArterial'
    TOWN_PRIVATE='townPrivate'
    TOWN_LOCAL='townLocal'
    TOWN_PLAY_STREET='townPlayStreet'


class e_road_lanes_laneSection_lcr_lane_roadMark_laneChange(str, Enum):
    INCREASE='increase'
    DECREASE='decrease'
    BOTH='both'
    NONE='none'


class e_road_lanes_laneSection_lr_lane_access_rule(str, Enum):
    ALLOW='allow'
    DENY='deny'


class e_road_link_elementType(str, Enum):
    ROAD='road'
    JUNCTION='junction'


class e_road_objects_object_parkingSpace_access(str, Enum):
    ALL='all'
    CAR='car'
    WOMEN='women'
    HANDICAPPED='handicapped'
    BUS='bus'
    TRUCK='truck'
    ELECTRIC='electric'
    RESIDENTS='residents'


class e_road_railroad_switch_position(str, Enum):
    DYNAMIC='dynamic'
    STRAIGHT='straight'
    TURN='turn'


class e_road_signals_signal_reference_elementType(str, Enum):
    OBJECT='object'
    SIGNAL='signal'


class e_road_surface_CRG_mode(str, Enum):
    ATTACHED='attached'
    ATTACHED_0='attached0'
    GENUINE='genuine'
    GLOBAL='global'


class e_road_surface_CRG_purpose(str, Enum):
    ELEVATION='elevation'
    FRICTION='friction'


class e_sideType(str, Enum):
    LEFT='left'
    RIGHT='right'
    FRONT='front'
    REAR='rear'


class e_station_platform_segment_side(str, Enum):
    LEFT='left'
    RIGHT='right'


class e_station_type(str, Enum):
    SMALL='small'
    MEDIUM='medium'
    LARGE='large'


class e_trafficRule(str, Enum):
    RHT='RHT'
    LHT='LHT'


class e_tunnelType(str, Enum):
    STANDARD='standard'
    UNDERPASS='underpass' # i.e. sides are open for daylight


class e_unitDistance(str, Enum):
    M='m'
    KM='km'
    FT='ft'
    MILE='mile'


class e_unitDistance13(str, Enum):
    M='m'
    KM='km'
    FT='ft'
    MILE='mile'


class e_unitMass(str, Enum):
    KG='kg'
    T='t'


class e_unitMass14(str, Enum):
    KG='kg'
    T='t'


class e_unitSlope(str, Enum):
    _='%'


class e_unitSlope15(str, Enum):
    _='%'


class e_unitSpeed(str, Enum):
    MS='m/s'
    MPH='mph'
    KMH='km/h'


class e_unitSpeed16(str, Enum):
    MS='m/s'
    MPH='mph'
    KMH='km/h'


class t_bool(str, Enum):
    TRUE='true'
    FALSE='false'


class t_yesNo(str, Enum):
    YES='yes'
    NO='no'


class t_yesNo19(str, Enum):
    YES='yes'
    NO='no'


#
# Start data representation classes
#
class _OpenDriveElement1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _OpenDriveElement1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _OpenDriveElement1.subclass:
            return _OpenDriveElement1.subclass(*args_, **kwargs_)
        else:
            return _OpenDriveElement1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='_OpenDriveElement1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_OpenDriveElement1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == '_OpenDriveElement1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_OpenDriveElement1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='_OpenDriveElement1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_OpenDriveElement1'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='_OpenDriveElement1', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class _OpenDriveElement1


class t_dataQuality2(GeneratedsSuper):
    """t_dataQuality2 -- Raw data or data from external sources that is integrated in ASAM OpenDRIVE may be of varying quality. It is possible to describe quality and accuracy of external data in ASAM OpenDRIVE.
    The description of the data quality is represented by
    <
    dataQuality
    >
    elements. They may be stored at any position in ASAM OpenDRIVE.
    Measurement data derived from external sources like GPS that is integrated in ASAM OpenDRIVE may be inaccurate. The error range, given in [m], may be listed in the application.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, error=None, rawData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.error = error
        self.error_nsprefix_ = None
        self.rawData = rawData
        self.rawData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_dataQuality2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_dataQuality2.subclass:
            return t_dataQuality2.subclass(*args_, **kwargs_)
        else:
            return t_dataQuality2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.error is not None or
            self.rawData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_dataQuality2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_dataQuality2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_dataQuality2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_dataQuality2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_dataQuality2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.error is not None:
            namespaceprefix_ = self.error_nsprefix_ + ':' if (UseCapturedNS_ and self.error_nsprefix_) else ''
            self.error.export(outfile, level, namespaceprefix_, namespacedef_='', name_='error', pretty_print=pretty_print)
        if self.rawData is not None:
            namespaceprefix_ = self.rawData_nsprefix_ + ':' if (UseCapturedNS_ and self.rawData_nsprefix_) else ''
            self.rawData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rawData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'error':
            obj_ = t_dataQuality_Error.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.error = obj_
            obj_.original_tagname_ = 'error'
        elif nodeName_ == 'rawData':
            obj_ = t_dataQuality_RawData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rawData = obj_
            obj_.original_tagname_ = 'rawData'
# end class t_dataQuality2


class t_dataQuality_Error3(GeneratedsSuper):
    """t_dataQuality_Error3 -- The absolute or relative errors of road data are described by
    <
    error
    >
    elements within the
    <
    dataQuality
    >
    element.
    xyAbsolute -- Absolute error of the road data in x/y direction
    xyRelative -- Relative error of the road data in x/y direction
    zAbsolute -- Absolute error of the road data in z direction
    zRelative -- Relative error of the road data in z direction
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xyAbsolute=None, xyRelative=None, zAbsolute=None, zRelative=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xyAbsolute = _cast(float, xyAbsolute)
        self.xyAbsolute_nsprefix_ = None
        self.xyRelative = _cast(float, xyRelative)
        self.xyRelative_nsprefix_ = None
        self.zAbsolute = _cast(float, zAbsolute)
        self.zAbsolute_nsprefix_ = None
        self.zRelative = _cast(float, zRelative)
        self.zRelative_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_dataQuality_Error3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_dataQuality_Error3.subclass:
            return t_dataQuality_Error3.subclass(*args_, **kwargs_)
        else:
            return t_dataQuality_Error3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_Error3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_dataQuality_Error3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_dataQuality_Error3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_dataQuality_Error3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_dataQuality_Error3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_dataQuality_Error3'):
        if self.xyAbsolute is not None and 'xyAbsolute' not in already_processed:
            already_processed.add('xyAbsolute')
            outfile.write(' xyAbsolute="%s"' % self.gds_format_double(self.xyAbsolute, input_name='xyAbsolute'))
        if self.xyRelative is not None and 'xyRelative' not in already_processed:
            already_processed.add('xyRelative')
            outfile.write(' xyRelative="%s"' % self.gds_format_double(self.xyRelative, input_name='xyRelative'))
        if self.zAbsolute is not None and 'zAbsolute' not in already_processed:
            already_processed.add('zAbsolute')
            outfile.write(' zAbsolute="%s"' % self.gds_format_double(self.zAbsolute, input_name='zAbsolute'))
        if self.zRelative is not None and 'zRelative' not in already_processed:
            already_processed.add('zRelative')
            outfile.write(' zRelative="%s"' % self.gds_format_double(self.zRelative, input_name='zRelative'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_Error3', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xyAbsolute', node)
        if value is not None and 'xyAbsolute' not in already_processed:
            already_processed.add('xyAbsolute')
            value = self.gds_parse_double(value, node, 'xyAbsolute')
            self.xyAbsolute = value
        value = find_attr_value_('xyRelative', node)
        if value is not None and 'xyRelative' not in already_processed:
            already_processed.add('xyRelative')
            value = self.gds_parse_double(value, node, 'xyRelative')
            self.xyRelative = value
        value = find_attr_value_('zAbsolute', node)
        if value is not None and 'zAbsolute' not in already_processed:
            already_processed.add('zAbsolute')
            value = self.gds_parse_double(value, node, 'zAbsolute')
            self.zAbsolute = value
        value = find_attr_value_('zRelative', node)
        if value is not None and 'zRelative' not in already_processed:
            already_processed.add('zRelative')
            value = self.gds_parse_double(value, node, 'zRelative')
            self.zRelative = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class t_dataQuality_Error3


class t_dataQuality_RawData4(GeneratedsSuper):
    """t_dataQuality_RawData4 -- Some basic metadata containing information about raw data included in ASAM OpenDRIVE is described by the
    <
    rawData
    >
    element within the
    <
    dataQuality
    >
    element.
    date -- Date of the delivery of raw data, to be given in ISO 8601 notification (YYYY-MM-DDTHH:MM:SS) [9]. Time-of-day may be omitted
    postProcessing -- Information about the kind of data handling before exporting data into the ASAM OpenDRIVE file
    postProcessingComment -- Comments concerning the postprocessing attribute. Free text, depending on the application
    source -- Source that has been used for retrieving the raw data; further sources to be added in upcoming versions
    sourceComment -- Comments concerning the @source . Free text, depending on the application
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, date=None, postProcessing=None, postProcessingComment=None, source=None, sourceComment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.date = _cast(None, date)
        self.date_nsprefix_ = None
        self.postProcessing = _cast(None, postProcessing)
        self.postProcessing_nsprefix_ = None
        self.postProcessingComment = _cast(None, postProcessingComment)
        self.postProcessingComment_nsprefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.sourceComment = _cast(None, sourceComment)
        self.sourceComment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_dataQuality_RawData4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_dataQuality_RawData4.subclass:
            return t_dataQuality_RawData4.subclass(*args_, **kwargs_)
        else:
            return t_dataQuality_RawData4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_dataQuality_RawData_PostProcessing(self, value):
        # Validate type e_dataQuality_RawData_PostProcessing, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['raw', 'cleaned', 'processed', 'fused']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_dataQuality_RawData_PostProcessing' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_dataQuality_RawData_Source(self, value):
        # Validate type e_dataQuality_RawData_Source, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['sensor', 'cadaster', 'custom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_dataQuality_RawData_Source' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_RawData4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_dataQuality_RawData4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_dataQuality_RawData4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_dataQuality_RawData4')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_dataQuality_RawData4', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_dataQuality_RawData4'):
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.date), input_name='date')), ))
        if self.postProcessing is not None and 'postProcessing' not in already_processed:
            already_processed.add('postProcessing')
            outfile.write(' postProcessing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.postProcessing), input_name='postProcessing')), ))
        if self.postProcessingComment is not None and 'postProcessingComment' not in already_processed:
            already_processed.add('postProcessingComment')
            outfile.write(' postProcessingComment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.postProcessingComment), input_name='postProcessingComment')), ))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.sourceComment is not None and 'sourceComment' not in already_processed:
            already_processed.add('sourceComment')
            outfile.write(' sourceComment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sourceComment), input_name='sourceComment')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_RawData4', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('postProcessing', node)
        if value is not None and 'postProcessing' not in already_processed:
            already_processed.add('postProcessing')
            self.postProcessing = value
            self.validate_e_dataQuality_RawData_PostProcessing(self.postProcessing)    # validate type e_dataQuality_RawData_PostProcessing
        value = find_attr_value_('postProcessingComment', node)
        if value is not None and 'postProcessingComment' not in already_processed:
            already_processed.add('postProcessingComment')
            self.postProcessingComment = value
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
            self.validate_e_dataQuality_RawData_Source(self.source)    # validate type e_dataQuality_RawData_Source
        value = find_attr_value_('sourceComment', node)
        if value is not None and 'sourceComment' not in already_processed:
            already_processed.add('sourceComment')
            self.sourceComment = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class t_dataQuality_RawData4


class t_header_GeoReference6(GeneratedsSuper):
    """t_header_GeoReference6 -- Spatial reference systems are standardized by the European Petroleum Survey Group Geodesy (EPSG) and are defined by parameters describing the geodetic datum. A geodetic datum is a coordinate reference system for a collection of positions that are relative to an ellipsoid model of the earth.
    A geodetic datum is described by a projection string according to PROJ, that is, a format for the exchange of data between two coordinate systems. This data shall be marked as CDATA, because it may contain characters that interfere with the XML syntax of an element
    ’
    s attribute.
    In ASAM OpenDRIVE, the information about the geographic reference of an ASAM OpenDRIVE dataset is represented by the
    <
    geoReference
    >
    element within the
    <
    header
    >
    element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dataQuality=None, include=None, userData=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_header_GeoReference6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_header_GeoReference6.subclass:
            return t_header_GeoReference6.subclass(*args_, **kwargs_)
        else:
            return t_header_GeoReference6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.dataQuality or
            self.include or
            self.userData or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_GeoReference6', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_header_GeoReference6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_header_GeoReference6':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header_GeoReference6')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_header_GeoReference6'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_GeoReference6', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dataQuality', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dataQuality'):
              self.add_dataQuality(obj_.value)
            elif hasattr(self, 'set_dataQuality'):
              self.set_dataQuality(obj_.value)
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'include', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_include'):
              self.add_include(obj_.value)
            elif hasattr(self, 'set_include'):
              self.set_include(obj_.value)
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'userData', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_userData'):
              self.add_userData(obj_.value)
            elif hasattr(self, 'set_userData'):
              self.set_userData(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class t_header_GeoReference6


class t_include8(GeneratedsSuper):
    """t_include8 -- ASAM OpenDRIVE allows including external files into the ASAM OpenDRIVE file. The processing of the files depends on the application.
    Included data is represented by
    <
    include
    >
    elements. They may be stored at any position in ASAM OpenDRIVE.
    file -- Location of the file that is to be included
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, file=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_include8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_include8.subclass:
            return t_include8.subclass(*args_, **kwargs_)
        else:
            return t_include8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_include8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_include8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_include8':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_include8')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_include8', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_include8'):
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_include8', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class t_include8


class t_userData9(GeneratedsSuper):
    """t_userData9 -- Ancillary data should be described near the element it refers to. Ancillary data contains data that are not yet described in ASAM OpenDRIVE, or data that is needed by an application for a specific reason. Examples are different road textures.
    In ASAM OpenDRIVE, ancillary data is represented by
    <
    userData
    >
    elements. They may be stored at any element in ASAM OpenDRIVE.
    code -- Code for the user data. Free text, depending on application.
    value -- User data. Free text, depending on application.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, code=None, value=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_userData9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_userData9.subclass:
            return t_userData9.subclass(*args_, **kwargs_)
        else:
            return t_userData9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_userData9', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_userData9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_userData9':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_userData9')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_userData9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_userData9'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_userData9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 't_userData9')
        self.anytypeobjs_.append(content_)
# end class t_userData9


class OpenDRIVE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, header=None, road=None, controller=None, junction=None, junctionGroup=None, station=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.header = header
        self.header_nsprefix_ = None
        if road is None:
            self.road = []
        else:
            self.road = road
        self.road_nsprefix_ = None
        if controller is None:
            self.controller = []
        else:
            self.controller = controller
        self.controller_nsprefix_ = None
        if junction is None:
            self.junction = []
        else:
            self.junction = junction
        self.junction_nsprefix_ = None
        if junctionGroup is None:
            self.junctionGroup = []
        else:
            self.junctionGroup = junctionGroup
        self.junctionGroup_nsprefix_ = None
        if station is None:
            self.station = []
        else:
            self.station = station
        self.station_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenDRIVE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenDRIVE.subclass:
            return OpenDRIVE.subclass(*args_, **kwargs_)
        else:
            return OpenDRIVE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.header is not None or
            self.road or
            self.controller or
            self.junction or
            self.junctionGroup or
            self.station or
            self.dataQuality or
            self.include or
            self.userData
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OpenDRIVE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OpenDRIVE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OpenDRIVE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OpenDRIVE')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OpenDRIVE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OpenDRIVE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OpenDRIVE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.header is not None:
            namespaceprefix_ = self.header_nsprefix_ + ':' if (UseCapturedNS_ and self.header_nsprefix_) else ''
            self.header.export(outfile, level, namespaceprefix_, namespacedef_='', name_='header', pretty_print=pretty_print)
        for road_ in self.road:
            namespaceprefix_ = self.road_nsprefix_ + ':' if (UseCapturedNS_ and self.road_nsprefix_) else ''
            road_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='road', pretty_print=pretty_print)
        for controller_ in self.controller:
            namespaceprefix_ = self.controller_nsprefix_ + ':' if (UseCapturedNS_ and self.controller_nsprefix_) else ''
            controller_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='controller', pretty_print=pretty_print)
        for junction_ in self.junction:
            namespaceprefix_ = self.junction_nsprefix_ + ':' if (UseCapturedNS_ and self.junction_nsprefix_) else ''
            junction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='junction', pretty_print=pretty_print)
        for junctionGroup_ in self.junctionGroup:
            namespaceprefix_ = self.junctionGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.junctionGroup_nsprefix_) else ''
            junctionGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='junctionGroup', pretty_print=pretty_print)
        for station_ in self.station:
            namespaceprefix_ = self.station_nsprefix_ + ':' if (UseCapturedNS_ and self.station_nsprefix_) else ''
            station_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='station', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'header':
            obj_ = t_header.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'road':
            obj_ = t_road.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.road.append(obj_)
            obj_.original_tagname_ = 'road'
        elif nodeName_ == 'controller':
            obj_ = t_controller.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.controller.append(obj_)
            obj_.original_tagname_ = 'controller'
        elif nodeName_ == 'junction':
            obj_ = t_junction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.junction.append(obj_)
            obj_.original_tagname_ = 'junction'
        elif nodeName_ == 'junctionGroup':
            obj_ = t_junctionGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.junctionGroup.append(obj_)
            obj_.original_tagname_ = 'junctionGroup'
        elif nodeName_ == 'station':
            obj_ = t_station.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.station.append(obj_)
            obj_.original_tagname_ = 'station'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
# end class OpenDRIVE


class _OpenDriveElement(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _OpenDriveElement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _OpenDriveElement.subclass:
            return _OpenDriveElement.subclass(*args_, **kwargs_)
        else:
            return _OpenDriveElement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='_OpenDriveElement', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_OpenDriveElement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == '_OpenDriveElement':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_OpenDriveElement')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='_OpenDriveElement', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_OpenDriveElement'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='_OpenDriveElement', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class _OpenDriveElement


class t_dataQuality(GeneratedsSuper):
    """t_dataQuality -- Raw data or data from external sources that is integrated in ASAM OpenDRIVE may be of varying quality. It is possible to describe quality and accuracy of external data in ASAM OpenDRIVE.
    The description of the data quality is represented by
    <
    dataQuality
    >
    elements. They may be stored at any position in ASAM OpenDRIVE.
    Measurement data derived from external sources like GPS that is integrated in ASAM OpenDRIVE may be inaccurate. The error range, given in [m], may be listed in the application.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, error=None, rawData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.error = error
        self.error_nsprefix_ = None
        self.rawData = rawData
        self.rawData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_dataQuality)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_dataQuality.subclass:
            return t_dataQuality.subclass(*args_, **kwargs_)
        else:
            return t_dataQuality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.error is not None or
            self.rawData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_dataQuality')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_dataQuality':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_dataQuality')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_dataQuality', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_dataQuality'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.error is not None:
            namespaceprefix_ = self.error_nsprefix_ + ':' if (UseCapturedNS_ and self.error_nsprefix_) else ''
            self.error.export(outfile, level, namespaceprefix_, namespacedef_='', name_='error', pretty_print=pretty_print)
        if self.rawData is not None:
            namespaceprefix_ = self.rawData_nsprefix_ + ':' if (UseCapturedNS_ and self.rawData_nsprefix_) else ''
            self.rawData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rawData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'error':
            obj_ = t_dataQuality_Error.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.error = obj_
            obj_.original_tagname_ = 'error'
        elif nodeName_ == 'rawData':
            obj_ = t_dataQuality_RawData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rawData = obj_
            obj_.original_tagname_ = 'rawData'
# end class t_dataQuality


class t_dataQuality_Error(GeneratedsSuper):
    """t_dataQuality_Error -- The absolute or relative errors of road data are described by
    <
    error
    >
    elements within the
    <
    dataQuality
    >
    element.
    xyAbsolute -- Absolute error of the road data in x/y direction
    xyRelative -- Relative error of the road data in x/y direction
    zAbsolute -- Absolute error of the road data in z direction
    zRelative -- Relative error of the road data in z direction
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xyAbsolute=None, xyRelative=None, zAbsolute=None, zRelative=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xyAbsolute = _cast(float, xyAbsolute)
        self.xyAbsolute_nsprefix_ = None
        self.xyRelative = _cast(float, xyRelative)
        self.xyRelative_nsprefix_ = None
        self.zAbsolute = _cast(float, zAbsolute)
        self.zAbsolute_nsprefix_ = None
        self.zRelative = _cast(float, zRelative)
        self.zRelative_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_dataQuality_Error)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_dataQuality_Error.subclass:
            return t_dataQuality_Error.subclass(*args_, **kwargs_)
        else:
            return t_dataQuality_Error(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_Error', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_dataQuality_Error')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_dataQuality_Error':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_dataQuality_Error')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_dataQuality_Error', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_dataQuality_Error'):
        if self.xyAbsolute is not None and 'xyAbsolute' not in already_processed:
            already_processed.add('xyAbsolute')
            outfile.write(' xyAbsolute="%s"' % self.gds_format_double(self.xyAbsolute, input_name='xyAbsolute'))
        if self.xyRelative is not None and 'xyRelative' not in already_processed:
            already_processed.add('xyRelative')
            outfile.write(' xyRelative="%s"' % self.gds_format_double(self.xyRelative, input_name='xyRelative'))
        if self.zAbsolute is not None and 'zAbsolute' not in already_processed:
            already_processed.add('zAbsolute')
            outfile.write(' zAbsolute="%s"' % self.gds_format_double(self.zAbsolute, input_name='zAbsolute'))
        if self.zRelative is not None and 'zRelative' not in already_processed:
            already_processed.add('zRelative')
            outfile.write(' zRelative="%s"' % self.gds_format_double(self.zRelative, input_name='zRelative'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_Error', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xyAbsolute', node)
        if value is not None and 'xyAbsolute' not in already_processed:
            already_processed.add('xyAbsolute')
            value = self.gds_parse_double(value, node, 'xyAbsolute')
            self.xyAbsolute = value
        value = find_attr_value_('xyRelative', node)
        if value is not None and 'xyRelative' not in already_processed:
            already_processed.add('xyRelative')
            value = self.gds_parse_double(value, node, 'xyRelative')
            self.xyRelative = value
        value = find_attr_value_('zAbsolute', node)
        if value is not None and 'zAbsolute' not in already_processed:
            already_processed.add('zAbsolute')
            value = self.gds_parse_double(value, node, 'zAbsolute')
            self.zAbsolute = value
        value = find_attr_value_('zRelative', node)
        if value is not None and 'zRelative' not in already_processed:
            already_processed.add('zRelative')
            value = self.gds_parse_double(value, node, 'zRelative')
            self.zRelative = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class t_dataQuality_Error


class t_dataQuality_RawData(GeneratedsSuper):
    """t_dataQuality_RawData -- Some basic metadata containing information about raw data included in ASAM OpenDRIVE is described by the
    <
    rawData
    >
    element within the
    <
    dataQuality
    >
    element.
    date -- Date of the delivery of raw data, to be given in ISO 8601 notification (YYYY-MM-DDTHH:MM:SS) [9]. Time-of-day may be omitted
    postProcessing -- Information about the kind of data handling before exporting data into the ASAM OpenDRIVE file
    postProcessingComment -- Comments concerning the postprocessing attribute. Free text, depending on the application
    source -- Source that has been used for retrieving the raw data; further sources to be added in upcoming versions
    sourceComment -- Comments concerning the @source . Free text, depending on the application
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, date=None, postProcessing=None, postProcessingComment=None, source=None, sourceComment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.date = _cast(None, date)
        self.date_nsprefix_ = None
        self.postProcessing = _cast(None, postProcessing)
        self.postProcessing_nsprefix_ = None
        self.postProcessingComment = _cast(None, postProcessingComment)
        self.postProcessingComment_nsprefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.sourceComment = _cast(None, sourceComment)
        self.sourceComment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_dataQuality_RawData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_dataQuality_RawData.subclass:
            return t_dataQuality_RawData.subclass(*args_, **kwargs_)
        else:
            return t_dataQuality_RawData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_dataQuality_RawData_PostProcessing(self, value):
        # Validate type e_dataQuality_RawData_PostProcessing, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['raw', 'cleaned', 'processed', 'fused']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_dataQuality_RawData_PostProcessing' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_dataQuality_RawData_Source(self, value):
        # Validate type e_dataQuality_RawData_Source, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['sensor', 'cadaster', 'custom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_dataQuality_RawData_Source' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_RawData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_dataQuality_RawData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_dataQuality_RawData':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_dataQuality_RawData')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_dataQuality_RawData', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_dataQuality_RawData'):
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.date), input_name='date')), ))
        if self.postProcessing is not None and 'postProcessing' not in already_processed:
            already_processed.add('postProcessing')
            outfile.write(' postProcessing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.postProcessing), input_name='postProcessing')), ))
        if self.postProcessingComment is not None and 'postProcessingComment' not in already_processed:
            already_processed.add('postProcessingComment')
            outfile.write(' postProcessingComment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.postProcessingComment), input_name='postProcessingComment')), ))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.sourceComment is not None and 'sourceComment' not in already_processed:
            already_processed.add('sourceComment')
            outfile.write(' sourceComment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sourceComment), input_name='sourceComment')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_dataQuality_RawData', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('postProcessing', node)
        if value is not None and 'postProcessing' not in already_processed:
            already_processed.add('postProcessing')
            self.postProcessing = value
            self.validate_e_dataQuality_RawData_PostProcessing(self.postProcessing)    # validate type e_dataQuality_RawData_PostProcessing
        value = find_attr_value_('postProcessingComment', node)
        if value is not None and 'postProcessingComment' not in already_processed:
            already_processed.add('postProcessingComment')
            self.postProcessingComment = value
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
            self.validate_e_dataQuality_RawData_Source(self.source)    # validate type e_dataQuality_RawData_Source
        value = find_attr_value_('sourceComment', node)
        if value is not None and 'sourceComment' not in already_processed:
            already_processed.add('sourceComment')
            self.sourceComment = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class t_dataQuality_RawData


class t_header(_OpenDriveElement):
    """t_header -- The
    <
    header
    >
    element is the very first element within the
    <
    OpenDRIVE
    >
    element.
    date -- Time/date of database creation according to ISO 8601 (preference: YYYY-MM-DDThh:mm:ss)
    east -- Maximum inertial x value
    name -- Database name
    north -- Maximum inertial y value
    revMajor -- Major revision number of OpenDRIVE format
    revMinor -- Minor revision number of OpenDRIVE format; 6 for OpenDrive 1.6
    south -- Minimum inertial y value
    vendor -- Vendor name
    version -- Version of this road network
    west -- Minimum inertial x value
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, date=None, east=None, name=None, north=None, revMajor=1, revMinor=None, south=None, vendor=None, version=None, west=None, geoReference=None, offset=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_header"), self).__init__( **kwargs_)
        self.date = _cast(None, date)
        self.date_nsprefix_ = None
        self.east = _cast(float, east)
        self.east_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.north = _cast(float, north)
        self.north_nsprefix_ = None
        self.revMajor = _cast(int, revMajor)
        self.revMajor_nsprefix_ = None
        self.revMinor = _cast(int, revMinor)
        self.revMinor_nsprefix_ = None
        self.south = _cast(float, south)
        self.south_nsprefix_ = None
        self.vendor = _cast(None, vendor)
        self.vendor_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.west = _cast(float, west)
        self.west_nsprefix_ = None
        self.geoReference = geoReference
        self.geoReference_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_header)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_header.subclass:
            return t_header.subclass(*args_, **kwargs_)
        else:
            return t_header(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.geoReference is not None or
            self.offset is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_header, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_header')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_header':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_header', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_header'):
        super(t_header, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header')
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.date), input_name='date')), ))
        if self.east is not None and 'east' not in already_processed:
            already_processed.add('east')
            outfile.write(' east="%s"' % self.gds_format_double(self.east, input_name='east'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.north is not None and 'north' not in already_processed:
            already_processed.add('north')
            outfile.write(' north="%s"' % self.gds_format_double(self.north, input_name='north'))
        if self.revMajor is not None and 'revMajor' not in already_processed:
            already_processed.add('revMajor')
            outfile.write(' revMajor="%s"' % self.gds_format_integer(self.revMajor, input_name='revMajor'))
        if self.revMinor is not None and 'revMinor' not in already_processed:
            already_processed.add('revMinor')
            outfile.write(' revMinor="%s"' % self.gds_format_integer(self.revMinor, input_name='revMinor'))
        if self.south is not None and 'south' not in already_processed:
            already_processed.add('south')
            outfile.write(' south="%s"' % self.gds_format_double(self.south, input_name='south'))
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vendor), input_name='vendor')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.west is not None and 'west' not in already_processed:
            already_processed.add('west')
            outfile.write(' west="%s"' % self.gds_format_double(self.west, input_name='west'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header', fromsubclass_=False, pretty_print=True):
        super(t_header, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.geoReference is not None:
            namespaceprefix_ = self.geoReference_nsprefix_ + ':' if (UseCapturedNS_ and self.geoReference_nsprefix_) else ''
            self.geoReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geoReference', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('east', node)
        if value is not None and 'east' not in already_processed:
            already_processed.add('east')
            value = self.gds_parse_double(value, node, 'east')
            self.east = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('north', node)
        if value is not None and 'north' not in already_processed:
            already_processed.add('north')
            value = self.gds_parse_double(value, node, 'north')
            self.north = value
        value = find_attr_value_('revMajor', node)
        if value is not None and 'revMajor' not in already_processed:
            already_processed.add('revMajor')
            self.revMajor = self.gds_parse_integer(value, node, 'revMajor')
        value = find_attr_value_('revMinor', node)
        if value is not None and 'revMinor' not in already_processed:
            already_processed.add('revMinor')
            self.revMinor = self.gds_parse_integer(value, node, 'revMinor')
        value = find_attr_value_('south', node)
        if value is not None and 'south' not in already_processed:
            already_processed.add('south')
            value = self.gds_parse_double(value, node, 'south')
            self.south = value
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('west', node)
        if value is not None and 'west' not in already_processed:
            already_processed.add('west')
            value = self.gds_parse_double(value, node, 'west')
            self.west = value
        super(t_header, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'geoReference':
            obj_ = t_header_GeoReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geoReference = obj_
            obj_.original_tagname_ = 'geoReference'
        elif nodeName_ == 'offset':
            obj_ = t_header_Offset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_header, self)._buildChildren(child_, node, nodeName_, True)
# end class t_header


class t_header_GeoReference(GeneratedsSuper):
    """t_header_GeoReference -- Spatial reference systems are standardized by the European Petroleum Survey Group Geodesy (EPSG) and are defined by parameters describing the geodetic datum. A geodetic datum is a coordinate reference system for a collection of positions that are relative to an ellipsoid model of the earth.
    A geodetic datum is described by a projection string according to PROJ, that is, a format for the exchange of data between two coordinate systems. This data shall be marked as CDATA, because it may contain characters that interfere with the XML syntax of an element
    ’
    s attribute.
    In ASAM OpenDRIVE, the information about the geographic reference of an ASAM OpenDRIVE dataset is represented by the
    <
    geoReference
    >
    element within the
    <
    header
    >
    element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dataQuality=None, include=None, userData=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_header_GeoReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_header_GeoReference.subclass:
            return t_header_GeoReference.subclass(*args_, **kwargs_)
        else:
            return t_header_GeoReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.dataQuality or
            self.include or
            self.userData or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_GeoReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_header_GeoReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_header_GeoReference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header_GeoReference')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write( self.valueOf_ )
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_header_GeoReference'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_GeoReference', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dataQuality', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dataQuality'):
              self.add_dataQuality(obj_.value)
            elif hasattr(self, 'set_dataQuality'):
              self.set_dataQuality(obj_.value)
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'include', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_include'):
              self.add_include(obj_.value)
            elif hasattr(self, 'set_include'):
              self.set_include(obj_.value)
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'userData', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_userData'):
              self.add_userData(obj_.value)
            elif hasattr(self, 'set_userData'):
              self.set_userData(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class t_header_GeoReference


class t_header_Offset(_OpenDriveElement):
    """t_header_Offset -- To avoid large coordinates, an offset of the whole dataset may be applied using the
    <
    offset
    >
    element. It enables inertial relocation and re-orientation of datasets. The dataset is first translated by @x, @y, and @z. Afterwards, it is rotated by @hdg around the new origin. Rotation around the z-axis should be avoided. In ASAM OpenDRIVE, the offset of a database is represented by the
    <
    offset
    >
    element within the
    <
    header
    >
    element.
    hdg -- Heading offset (rotation around resulting z-axis)
    x -- Inertial x offset
    y -- Inertial y offset
    z -- Inertial z offset
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, hdg=None, x=None, y=None, z=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_header_Offset"), self).__init__( **kwargs_)
        self.hdg = _cast(float, hdg)
        self.hdg_nsprefix_ = None
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_header_Offset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_header_Offset.subclass:
            return t_header_Offset.subclass(*args_, **kwargs_)
        else:
            return t_header_Offset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.dataQuality or
            self.include or
            self.userData or
            super(t_header_Offset, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_Offset', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_header_Offset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_header_Offset':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header_Offset')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_header_Offset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_header_Offset'):
        super(t_header_Offset, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header_Offset')
        if self.hdg is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            outfile.write(' hdg="%s"' % self.gds_format_double(self.hdg, input_name='hdg'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_Offset', fromsubclass_=False, pretty_print=True):
        super(t_header_Offset, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hdg', node)
        if value is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            value = self.gds_parse_double(value, node, 'hdg')
            self.hdg = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            value = self.gds_parse_double(value, node, 'x')
            self.x = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            value = self.gds_parse_double(value, node, 'y')
            self.y = value
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            value = self.gds_parse_double(value, node, 'z')
            self.z = value
        super(t_header_Offset, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_header_Offset, self)._buildChildren(child_, node, nodeName_, True)
# end class t_header_Offset


class t_include(GeneratedsSuper):
    """t_include -- ASAM OpenDRIVE allows including external files into the ASAM OpenDRIVE file. The processing of the files depends on the application.
    Included data is represented by
    <
    include
    >
    elements. They may be stored at any position in ASAM OpenDRIVE.
    file -- Location of the file that is to be included
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, file=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_include)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_include.subclass:
            return t_include.subclass(*args_, **kwargs_)
        else:
            return t_include(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_include', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_include')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_include':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_include')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_include', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_include'):
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_include', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class t_include


class t_userData(GeneratedsSuper):
    """t_userData -- Ancillary data should be described near the element it refers to. Ancillary data contains data that are not yet described in ASAM OpenDRIVE, or data that is needed by an application for a specific reason. Examples are different road textures.
    In ASAM OpenDRIVE, ancillary data is represented by
    <
    userData
    >
    elements. They may be stored at any element in ASAM OpenDRIVE.
    code -- Code for the user data. Free text, depending on application.
    value -- User data. Free text, depending on application.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, code=None, value=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_userData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_userData.subclass:
            return t_userData.subclass(*args_, **kwargs_)
        else:
            return t_userData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_userData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_userData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_userData':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_userData')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_userData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_userData'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_userData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 't_userData')
        self.anytypeobjs_.append(content_)
# end class t_userData


class t_road_railroad(_OpenDriveElement):
    """Container for all railroad definitions that shall be applied along a road.
    t_road_railroad -- Container for all railroad definitions that shall be applied along a road.
    The available set of railroad elements is currently limited to the definition of switches. All other entries shall be covered with the existing elements, for example, track definition by
    <
    road
    >
    , signal definition by
    <
    signal
    >
    , etc. Railroad-specific elements are defined against the background of streetcar applications.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, switch=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_railroad"), self).__init__( **kwargs_)
        if switch is None:
            self.switch = []
        else:
            self.switch = switch
        self.switch_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_railroad)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_railroad.subclass:
            return t_road_railroad.subclass(*args_, **kwargs_)
        else:
            return t_road_railroad(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.switch or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_railroad, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_railroad')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_railroad':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_railroad', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_railroad'):
        super(t_road_railroad, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad', fromsubclass_=False, pretty_print=True):
        super(t_road_railroad, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for switch_ in self.switch:
            namespaceprefix_ = self.switch_nsprefix_ + ':' if (UseCapturedNS_ and self.switch_nsprefix_) else ''
            switch_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='switch', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_railroad, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'switch':
            obj_ = t_road_railroad_switch.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.switch.append(obj_)
            obj_.original_tagname_ = 'switch'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_railroad, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_railroad


class t_road_railroad_switch(_OpenDriveElement):
    """id -- Unique ID of the switch; preferably an integer number, see uint32_t
    name -- Unique name of the switch
    position -- Either a switch can be operated (dynamic) or it is in a static position
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, name=None, position=None, mainTrack=None, sideTrack=None, partner=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_railroad_switch"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.position = _cast(None, position)
        self.position_nsprefix_ = None
        self.mainTrack = mainTrack
        self.mainTrack_nsprefix_ = None
        self.sideTrack = sideTrack
        self.sideTrack_nsprefix_ = None
        self.partner = partner
        self.partner_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_railroad_switch)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_railroad_switch.subclass:
            return t_road_railroad_switch.subclass(*args_, **kwargs_)
        else:
            return t_road_railroad_switch(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_road_railroad_switch_position(self, value):
        # Validate type e_road_railroad_switch_position, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['dynamic', 'straight', 'turn']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_road_railroad_switch_position' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.mainTrack is not None or
            self.sideTrack is not None or
            self.partner is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_railroad_switch, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_railroad_switch')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_railroad_switch':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_railroad_switch', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_railroad_switch'):
        super(t_road_railroad_switch, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.position), input_name='position')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch', fromsubclass_=False, pretty_print=True):
        super(t_road_railroad_switch, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mainTrack is not None:
            namespaceprefix_ = self.mainTrack_nsprefix_ + ':' if (UseCapturedNS_ and self.mainTrack_nsprefix_) else ''
            self.mainTrack.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mainTrack', pretty_print=pretty_print)
        if self.sideTrack is not None:
            namespaceprefix_ = self.sideTrack_nsprefix_ + ':' if (UseCapturedNS_ and self.sideTrack_nsprefix_) else ''
            self.sideTrack.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sideTrack', pretty_print=pretty_print)
        if self.partner is not None:
            namespaceprefix_ = self.partner_nsprefix_ + ':' if (UseCapturedNS_ and self.partner_nsprefix_) else ''
            self.partner.export(outfile, level, namespaceprefix_, namespacedef_='', name_='partner', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            self.position = value
            self.validate_e_road_railroad_switch_position(self.position)    # validate type e_road_railroad_switch_position
        super(t_road_railroad_switch, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mainTrack':
            obj_ = t_road_railroad_switch_mainTrack.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mainTrack = obj_
            obj_.original_tagname_ = 'mainTrack'
        elif nodeName_ == 'sideTrack':
            obj_ = t_road_railroad_switch_sideTrack.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sideTrack = obj_
            obj_.original_tagname_ = 'sideTrack'
        elif nodeName_ == 'partner':
            obj_ = t_road_railroad_switch_partner.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.partner = obj_
            obj_.original_tagname_ = 'partner'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_railroad_switch, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_railroad_switch


class t_road_railroad_switch_mainTrack(_OpenDriveElement):
    """dir -- direction, relative to the s-direction, on the main track for entering the side track via the switch
    id -- Unique ID of the main track, that is, the
    <
    road
    >
    element. Must be consistent with parent containing this
    <
    railroad
    >
    element.
    s -- s-coordinate of the switch, that is, the point where main track and side track meet
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, dir=None, id=None, s=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_railroad_switch_mainTrack"), self).__init__( **kwargs_)
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_railroad_switch_mainTrack)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_railroad_switch_mainTrack.subclass:
            return t_road_railroad_switch_mainTrack.subclass(*args_, **kwargs_)
        else:
            return t_road_railroad_switch_mainTrack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_elementDir(self, value):
        # Validate type e_elementDir, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_elementDir' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_railroad_switch_mainTrack, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_mainTrack', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_railroad_switch_mainTrack')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_railroad_switch_mainTrack':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch_mainTrack')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_railroad_switch_mainTrack', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_railroad_switch_mainTrack'):
        super(t_road_railroad_switch_mainTrack, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch_mainTrack')
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_mainTrack', fromsubclass_=False, pretty_print=True):
        super(t_road_railroad_switch_mainTrack, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.validate_e_elementDir(self.dir)    # validate type e_elementDir
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        super(t_road_railroad_switch_mainTrack, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_railroad_switch_mainTrack, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_railroad_switch_mainTrack


class t_road_railroad_switch_partner(_OpenDriveElement):
    """t_road_railroad_switch_partner -- Indicates the switch that leads out of a side track after it has been entered.
    id -- Unique ID of the partner switch
    name -- Unique name of the partner switch
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_railroad_switch_partner"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_railroad_switch_partner)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_railroad_switch_partner.subclass:
            return t_road_railroad_switch_partner.subclass(*args_, **kwargs_)
        else:
            return t_road_railroad_switch_partner(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_railroad_switch_partner, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_partner', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_railroad_switch_partner')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_railroad_switch_partner':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch_partner')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_railroad_switch_partner', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_railroad_switch_partner'):
        super(t_road_railroad_switch_partner, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch_partner')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_partner', fromsubclass_=False, pretty_print=True):
        super(t_road_railroad_switch_partner, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(t_road_railroad_switch_partner, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_railroad_switch_partner, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_railroad_switch_partner


class t_road_railroad_switch_sideTrack(_OpenDriveElement):
    """dir -- direction, relative to the s-direction, on the side track for after entering it via the switch
    id -- Unique ID of the side track, that is, the
    <
    road
    >
    element
    s -- s-coordinate of the switch on the side track
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, dir=None, id=None, s=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_railroad_switch_sideTrack"), self).__init__( **kwargs_)
        self.dir = _cast(None, dir)
        self.dir_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_railroad_switch_sideTrack)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_railroad_switch_sideTrack.subclass:
            return t_road_railroad_switch_sideTrack.subclass(*args_, **kwargs_)
        else:
            return t_road_railroad_switch_sideTrack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_elementDir(self, value):
        # Validate type e_elementDir, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_elementDir' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_railroad_switch_sideTrack, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_sideTrack', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_railroad_switch_sideTrack')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_railroad_switch_sideTrack':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch_sideTrack')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_railroad_switch_sideTrack', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_railroad_switch_sideTrack'):
        super(t_road_railroad_switch_sideTrack, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_railroad_switch_sideTrack')
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            outfile.write(' dir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dir), input_name='dir')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_railroad_switch_sideTrack', fromsubclass_=False, pretty_print=True):
        super(t_road_railroad_switch_sideTrack, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.add('dir')
            self.dir = value
            self.validate_e_elementDir(self.dir)    # validate type e_elementDir
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        super(t_road_railroad_switch_sideTrack, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_railroad_switch_sideTrack, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_railroad_switch_sideTrack


class t_station(_OpenDriveElement):
    """t_station -- Defines stations for tram and railroad applications and for automotive environments. May refer to multiple tracks and is therefore defined on the same level as junctions.
    id -- Unique ID within database
    name -- Unique name of the station
    type -- Type of station. Free text, depending on the application.
    e.g.: small, medium, large
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, name=None, type_=None, platform=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_station"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
        self.platform_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_station)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_station.subclass:
            return t_station.subclass(*args_, **kwargs_)
        else:
            return t_station(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_station_type(self, value):
        # Validate type e_station_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['small', 'medium', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_station_type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.platform or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_station, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_station')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_station':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_station')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_station', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_station'):
        super(t_station, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_station')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station', fromsubclass_=False, pretty_print=True):
        super(t_station, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for platform_ in self.platform:
            namespaceprefix_ = self.platform_nsprefix_ + ':' if (UseCapturedNS_ and self.platform_nsprefix_) else ''
            platform_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='platform', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_station_type(self.type_)    # validate type e_station_type
        super(t_station, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'platform':
            obj_ = t_station_platform.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.platform.append(obj_)
            obj_.original_tagname_ = 'platform'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_station, self)._buildChildren(child_, node, nodeName_, True)
# end class t_station


class t_station_platform(_OpenDriveElement):
    """t_station_platform -- Each
    <
    station
    >
    element must contain at least one
    <
    platform
    >
    element. Each
    <
    platform
    >
    element must contain at least one reference to a valid track segment.
    id -- Unique ID within database
    name -- Name of the platform. May be chosen freely.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, name=None, segment=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_station_platform"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
        self.segment_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_station_platform)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_station_platform.subclass:
            return t_station_platform.subclass(*args_, **kwargs_)
        else:
            return t_station_platform(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.segment or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_station_platform, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station_platform', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_station_platform')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_station_platform':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_station_platform')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_station_platform', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_station_platform'):
        super(t_station_platform, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_station_platform')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station_platform', fromsubclass_=False, pretty_print=True):
        super(t_station_platform, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for segment_ in self.segment:
            namespaceprefix_ = self.segment_nsprefix_ + ':' if (UseCapturedNS_ and self.segment_nsprefix_) else ''
            segment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='segment', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(t_station_platform, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'segment':
            obj_ = t_station_platform_segment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.segment.append(obj_)
            obj_.original_tagname_ = 'segment'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_station_platform, self)._buildChildren(child_, node, nodeName_, True)
# end class t_station_platform


class t_station_platform_segment(_OpenDriveElement):
    """t_station_platform_segment -- Each
    <
    platform
    >
    element is valid on one or more track segments. The
    <
    segment
    >
    element must be specified.
    roadId -- Unique ID of the
    <
    road
    >
    element (track) that accompanies the platform
    sEnd -- Maximum s-coordiante on
    <
    road
    >
    element that has an adjacent platform
    side -- Side of track on which the platform is situated when going from sStart to sEnd
    sStart -- Minimum s-coordinate on
    <
    road
    >
    element that has an adjacent platform
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, roadId=None, sEnd=None, side=None, sStart=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_station_platform_segment"), self).__init__( **kwargs_)
        self.roadId = _cast(None, roadId)
        self.roadId_nsprefix_ = None
        self.sEnd = _cast(float, sEnd)
        self.sEnd_nsprefix_ = None
        self.side = _cast(None, side)
        self.side_nsprefix_ = None
        self.sStart = _cast(float, sStart)
        self.sStart_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_station_platform_segment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_station_platform_segment.subclass:
            return t_station_platform_segment.subclass(*args_, **kwargs_)
        else:
            return t_station_platform_segment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_station_platform_segment_side(self, value):
        # Validate type e_station_platform_segment_side, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'right']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_station_platform_segment_side' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_station_platform_segment, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station_platform_segment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_station_platform_segment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_station_platform_segment':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_station_platform_segment')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_station_platform_segment', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_station_platform_segment'):
        super(t_station_platform_segment, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_station_platform_segment')
        if self.roadId is not None and 'roadId' not in already_processed:
            already_processed.add('roadId')
            outfile.write(' roadId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.roadId), input_name='roadId')), ))
        if self.sEnd is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            outfile.write(' sEnd="%s"' % self.gds_format_double(self.sEnd, input_name='sEnd'))
        if self.side is not None and 'side' not in already_processed:
            already_processed.add('side')
            outfile.write(' side=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.side), input_name='side')), ))
        if self.sStart is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            outfile.write(' sStart="%s"' % self.gds_format_double(self.sStart, input_name='sStart'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_station_platform_segment', fromsubclass_=False, pretty_print=True):
        super(t_station_platform_segment, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('roadId', node)
        if value is not None and 'roadId' not in already_processed:
            already_processed.add('roadId')
            self.roadId = value
        value = find_attr_value_('sEnd', node)
        if value is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            value = self.gds_parse_double(value, node, 'sEnd')
            self.sEnd = value
            self.validate_t_grEqZero(self.sEnd)    # validate type t_grEqZero
        value = find_attr_value_('side', node)
        if value is not None and 'side' not in already_processed:
            already_processed.add('side')
            self.side = value
            self.validate_e_station_platform_segment_side(self.side)    # validate type e_station_platform_segment_side
        value = find_attr_value_('sStart', node)
        if value is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            value = self.gds_parse_double(value, node, 'sStart')
            self.sStart = value
            self.validate_t_grEqZero(self.sStart)    # validate type t_grEqZero
        super(t_station_platform_segment, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_station_platform_segment, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_station_platform_segment


class t_junction(_OpenDriveElement):
    """t_junction -- Contains information about all possible connections between roads meeting at a physical junction.
    id -- Unique ID within database
    mainRoad -- The main road from which the connecting roads of the virtual junction branch off. This attribute is mandatory for virtual junctions and shall not be specified for other junction types.
    name -- Name of the junction. May be chosen freely.
    orientation -- Defines the relevance of the virtual junction according to the driving direction. This attribute is mandatory for virtual junctions and shall not be specified for other junction types. The enumerator "none" specifies that the virtual junction is valid in both directions.
    sEnd -- End position of the virtual junction in the reference line coordinate system. This attribute is mandatory for virtual junctions and shall not be specified for other junction types.
    sStart -- Start position of the virtual junction in the reference line coordinate system. This attribute is mandatory for virtual junctions and shall not be specified for other junction types.
    type -- Type of the junction. Common junctions are of type "default". This attribute is mandatory for virtual junctions and direct junctions. If the attribute is not specified, the junction type is "default".
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, mainRoad=None, name=None, orientation=None, sEnd=None, sStart=None, type_=None, connection=None, priority=None, controller=None, surface=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_junction"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.mainRoad = _cast(None, mainRoad)
        self.mainRoad_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.sEnd = _cast(float, sEnd)
        self.sEnd_nsprefix_ = None
        self.sStart = _cast(float, sStart)
        self.sStart_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if connection is None:
            self.connection = []
        else:
            self.connection = connection
        self.connection_nsprefix_ = None
        if priority is None:
            self.priority = []
        else:
            self.priority = priority
        self.priority_nsprefix_ = None
        if controller is None:
            self.controller = []
        else:
            self.controller = controller
        self.controller_nsprefix_ = None
        self.surface = surface
        self.surface_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction.subclass:
            return t_junction.subclass(*args_, **kwargs_)
        else:
            return t_junction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_orientation(self, value):
        # Validate type e_orientation, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_orientation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_junction_type(self, value):
        # Validate type e_junction_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['default', 'virtual', 'direct']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_junction_type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.connection or
            self.priority or
            self.controller or
            self.surface is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_junction, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_junction':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction'):
        super(t_junction, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.mainRoad is not None and 'mainRoad' not in already_processed:
            already_processed.add('mainRoad')
            outfile.write(' mainRoad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mainRoad), input_name='mainRoad')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if self.sEnd is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            outfile.write(' sEnd="%s"' % self.gds_format_double(self.sEnd, input_name='sEnd'))
        if self.sStart is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            outfile.write(' sStart="%s"' % self.gds_format_double(self.sStart, input_name='sStart'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction', fromsubclass_=False, pretty_print=True):
        super(t_junction, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for connection_ in self.connection:
            namespaceprefix_ = self.connection_nsprefix_ + ':' if (UseCapturedNS_ and self.connection_nsprefix_) else ''
            connection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='connection', pretty_print=pretty_print)
        for priority_ in self.priority:
            namespaceprefix_ = self.priority_nsprefix_ + ':' if (UseCapturedNS_ and self.priority_nsprefix_) else ''
            priority_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priority', pretty_print=pretty_print)
        for controller_ in self.controller:
            namespaceprefix_ = self.controller_nsprefix_ + ':' if (UseCapturedNS_ and self.controller_nsprefix_) else ''
            controller_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='controller', pretty_print=pretty_print)
        if self.surface is not None:
            namespaceprefix_ = self.surface_nsprefix_ + ':' if (UseCapturedNS_ and self.surface_nsprefix_) else ''
            self.surface.export(outfile, level, namespaceprefix_, namespacedef_='', name_='surface', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('mainRoad', node)
        if value is not None and 'mainRoad' not in already_processed:
            already_processed.add('mainRoad')
            self.mainRoad = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_e_orientation(self.orientation)    # validate type e_orientation
        value = find_attr_value_('sEnd', node)
        if value is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            value = self.gds_parse_double(value, node, 'sEnd')
            self.sEnd = value
            self.validate_t_grEqZero(self.sEnd)    # validate type t_grEqZero
        value = find_attr_value_('sStart', node)
        if value is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            value = self.gds_parse_double(value, node, 'sStart')
            self.sStart = value
            self.validate_t_grEqZero(self.sStart)    # validate type t_grEqZero
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_junction_type(self.type_)    # validate type e_junction_type
        super(t_junction, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'connection':
            obj_ = t_junction_connection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connection.append(obj_)
            obj_.original_tagname_ = 'connection'
        elif nodeName_ == 'priority':
            obj_ = t_junction_priority.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priority.append(obj_)
            obj_.original_tagname_ = 'priority'
        elif nodeName_ == 'controller':
            obj_ = t_junction_controller.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.controller.append(obj_)
            obj_.original_tagname_ = 'controller'
        elif nodeName_ == 'surface':
            obj_ = t_junction_surface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.surface = obj_
            obj_.original_tagname_ = 'surface'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_junction, self)._buildChildren(child_, node, nodeName_, True)
# end class t_junction


class t_junction_connection(_OpenDriveElement):
    """t_junction_connection -- Provides information about a single connection within a junction.
    connectingRoad -- ID of the connecting road
    contactPoint -- Contact point on the connecting road
    id -- Unique ID within the junction
    incomingRoad -- ID of the incoming road
    linkedRoad -- ID of the directly linked road. Only to be used for junctions of @type="direct".
    type -- Type of the connection. Regular connections are @type=
    “
    default
    ”
    . This attribute is mandatory for virtual connections.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, connectingRoad=None, contactPoint=None, id=None, incomingRoad=None, linkedRoad=None, type_=None, predecessor=None, successor=None, laneLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_junction_connection"), self).__init__( **kwargs_)
        self.connectingRoad = _cast(None, connectingRoad)
        self.connectingRoad_nsprefix_ = None
        self.contactPoint = _cast(None, contactPoint)
        self.contactPoint_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.incomingRoad = _cast(None, incomingRoad)
        self.incomingRoad_nsprefix_ = None
        self.linkedRoad = _cast(None, linkedRoad)
        self.linkedRoad_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.predecessor = predecessor
        self.predecessor_nsprefix_ = None
        self.successor = successor
        self.successor_nsprefix_ = None
        if laneLink is None:
            self.laneLink = []
        else:
            self.laneLink = laneLink
        self.laneLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_connection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_connection.subclass:
            return t_junction_connection.subclass(*args_, **kwargs_)
        else:
            return t_junction_connection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_contactPoint(self, value):
        # Validate type e_contactPoint, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'end']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_contactPoint' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_connection_type(self, value):
        # Validate type e_connection_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['default', 'virtual']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_connection_type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.predecessor is not None or
            self.successor is not None or
            self.laneLink or
            super(t_junction_connection, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_connection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_connection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_junction_connection':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_connection')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_connection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_connection'):
        super(t_junction_connection, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_connection')
        if self.connectingRoad is not None and 'connectingRoad' not in already_processed:
            already_processed.add('connectingRoad')
            outfile.write(' connectingRoad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.connectingRoad), input_name='connectingRoad')), ))
        if self.contactPoint is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            outfile.write(' contactPoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contactPoint), input_name='contactPoint')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.incomingRoad is not None and 'incomingRoad' not in already_processed:
            already_processed.add('incomingRoad')
            outfile.write(' incomingRoad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.incomingRoad), input_name='incomingRoad')), ))
        if self.linkedRoad is not None and 'linkedRoad' not in already_processed:
            already_processed.add('linkedRoad')
            outfile.write(' linkedRoad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.linkedRoad), input_name='linkedRoad')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_connection', fromsubclass_=False, pretty_print=True):
        super(t_junction_connection, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.predecessor is not None:
            namespaceprefix_ = self.predecessor_nsprefix_ + ':' if (UseCapturedNS_ and self.predecessor_nsprefix_) else ''
            self.predecessor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predecessor', pretty_print=pretty_print)
        if self.successor is not None:
            namespaceprefix_ = self.successor_nsprefix_ + ':' if (UseCapturedNS_ and self.successor_nsprefix_) else ''
            self.successor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='successor', pretty_print=pretty_print)
        for laneLink_ in self.laneLink:
            namespaceprefix_ = self.laneLink_nsprefix_ + ':' if (UseCapturedNS_ and self.laneLink_nsprefix_) else ''
            laneLink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='laneLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('connectingRoad', node)
        if value is not None and 'connectingRoad' not in already_processed:
            already_processed.add('connectingRoad')
            self.connectingRoad = value
        value = find_attr_value_('contactPoint', node)
        if value is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            self.contactPoint = value
            self.validate_e_contactPoint(self.contactPoint)    # validate type e_contactPoint
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('incomingRoad', node)
        if value is not None and 'incomingRoad' not in already_processed:
            already_processed.add('incomingRoad')
            self.incomingRoad = value
        value = find_attr_value_('linkedRoad', node)
        if value is not None and 'linkedRoad' not in already_processed:
            already_processed.add('linkedRoad')
            self.linkedRoad = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_connection_type(self.type_)    # validate type e_connection_type
        super(t_junction_connection, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'predecessor':
            obj_ = t_junction_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.predecessor = obj_
            obj_.original_tagname_ = 'predecessor'
        elif nodeName_ == 'successor':
            obj_ = t_junction_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.successor = obj_
            obj_.original_tagname_ = 'successor'
        elif nodeName_ == 'laneLink':
            obj_ = t_junction_connection_laneLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.laneLink.append(obj_)
            obj_.original_tagname_ = 'laneLink'
        super(t_junction_connection, self)._buildChildren(child_, node, nodeName_, True)
# end class t_junction_connection


class t_junction_connection_laneLink(_OpenDriveElement):
    """t_junction_connection_laneLink -- Provides information about the lanes that are linked between an incoming road and a connecting road. It is strongly recommended to provide this element. It is deprecated to omit the
    <
    laneLink
    >
    element.
    from -- ID of the incoming lane
    to -- ID of the connection lane
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, from_=None, to=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_junction_connection_laneLink"), self).__init__( **kwargs_)
        self.from_ = _cast(int, from_)
        self.from__nsprefix_ = None
        self.to = _cast(int, to)
        self.to_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_connection_laneLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_connection_laneLink.subclass:
            return t_junction_connection_laneLink.subclass(*args_, **kwargs_)
        else:
            return t_junction_connection_laneLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_junction_connection_laneLink, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_connection_laneLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_connection_laneLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_junction_connection_laneLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_connection_laneLink')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_connection_laneLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_connection_laneLink'):
        super(t_junction_connection_laneLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_connection_laneLink')
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from="%s"' % self.gds_format_integer(self.from_, input_name='from'))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to="%s"' % self.gds_format_integer(self.to, input_name='to'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_connection_laneLink', fromsubclass_=False, pretty_print=True):
        super(t_junction_connection_laneLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = self.gds_parse_integer(value, node, 'from')
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = self.gds_parse_integer(value, node, 'to')
        super(t_junction_connection_laneLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_junction_connection_laneLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_junction_connection_laneLink


class t_junction_controller(_OpenDriveElement):
    """t_junction_controller -- Lists the controllers that are used for the management of a junction.
    id -- ID of the controller
    sequence -- Sequence number (priority) of this controller with respect to other controllers in the same junction
    type -- Type of control for this junction. Free text, depending on the application.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, sequence=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_junction_controller"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_controller)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_controller.subclass:
            return t_junction_controller.subclass(*args_, **kwargs_)
        else:
            return t_junction_controller(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_junction_controller, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_controller', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_controller')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_junction_controller':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_controller')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_controller', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_controller'):
        super(t_junction_controller, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_controller')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_controller', fromsubclass_=False, pretty_print=True):
        super(t_junction_controller, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
            if self.sequence < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(t_junction_controller, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_junction_controller, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_junction_controller


class t_junction_predecessorSuccessor(_OpenDriveElement):
    """t_junction_predecessorSuccessor -- Provides detailed information about the predecessor / successor road of a virtual connection. Currently, only the @elementType
    “
    road
    ”
    is allowed.
    elementDir -- Direction, relative to the s-direction, of the connection on the preceding / succeding road
    elementId -- ID of the linked element
    elementS -- s-coordinate where the connection meets the preceding / succeding road.
    elementType -- Type of the linked element. Currently only "road" is allowed.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, elementDir=None, elementId=None, elementS=None, elementType='road', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_junction_predecessorSuccessor"), self).__init__( **kwargs_)
        self.elementDir = _cast(None, elementDir)
        self.elementDir_nsprefix_ = None
        self.elementId = _cast(None, elementId)
        self.elementId_nsprefix_ = None
        self.elementS = _cast(float, elementS)
        self.elementS_nsprefix_ = None
        self.elementType = _cast(None, elementType)
        self.elementType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_predecessorSuccessor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_predecessorSuccessor.subclass:
            return t_junction_predecessorSuccessor.subclass(*args_, **kwargs_)
        else:
            return t_junction_predecessorSuccessor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_elementDir(self, value):
        # Validate type e_elementDir, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_elementDir' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_junction_predecessorSuccessor, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_predecessorSuccessor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_predecessorSuccessor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_junction_predecessorSuccessor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_predecessorSuccessor')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_predecessorSuccessor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_predecessorSuccessor'):
        super(t_junction_predecessorSuccessor, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_predecessorSuccessor')
        if self.elementDir is not None and 'elementDir' not in already_processed:
            already_processed.add('elementDir')
            outfile.write(' elementDir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementDir), input_name='elementDir')), ))
        if self.elementId is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            outfile.write(' elementId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementId), input_name='elementId')), ))
        if self.elementS is not None and 'elementS' not in already_processed:
            already_processed.add('elementS')
            outfile.write(' elementS="%s"' % self.gds_format_double(self.elementS, input_name='elementS'))
        if self.elementType is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            outfile.write(' elementType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementType), input_name='elementType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_predecessorSuccessor', fromsubclass_=False, pretty_print=True):
        super(t_junction_predecessorSuccessor, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('elementDir', node)
        if value is not None and 'elementDir' not in already_processed:
            already_processed.add('elementDir')
            self.elementDir = value
            self.validate_e_elementDir(self.elementDir)    # validate type e_elementDir
        value = find_attr_value_('elementId', node)
        if value is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            self.elementId = value
        value = find_attr_value_('elementS', node)
        if value is not None and 'elementS' not in already_processed:
            already_processed.add('elementS')
            value = self.gds_parse_double(value, node, 'elementS')
            self.elementS = value
            self.validate_t_grEqZero(self.elementS)    # validate type t_grEqZero
        value = find_attr_value_('elementType', node)
        if value is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            self.elementType = value
        super(t_junction_predecessorSuccessor, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_junction_predecessorSuccessor, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_junction_predecessorSuccessor


class t_junction_priority(_OpenDriveElement):
    """t_junction_priority -- The junction priority record provides information about the priority of a connecting road over another connecting road. It is only required if priorities cannot be derived from signs or signals in a junction or on tracks leading to a junction.
    high -- ID of the prioritized connecting road
    low -- ID of the connecting road with lower priority
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, high=None, low=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_junction_priority"), self).__init__( **kwargs_)
        self.high = _cast(None, high)
        self.high_nsprefix_ = None
        self.low = _cast(None, low)
        self.low_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_priority)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_priority.subclass:
            return t_junction_priority.subclass(*args_, **kwargs_)
        else:
            return t_junction_priority(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_junction_priority, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_priority', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_priority')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_junction_priority':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_priority')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_priority', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_priority'):
        super(t_junction_priority, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_priority')
        if self.high is not None and 'high' not in already_processed:
            already_processed.add('high')
            outfile.write(' high=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.high), input_name='high')), ))
        if self.low is not None and 'low' not in already_processed:
            already_processed.add('low')
            outfile.write(' low=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.low), input_name='low')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_priority', fromsubclass_=False, pretty_print=True):
        super(t_junction_priority, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('high', node)
        if value is not None and 'high' not in already_processed:
            already_processed.add('high')
            self.high = value
        value = find_attr_value_('low', node)
        if value is not None and 'low' not in already_processed:
            already_processed.add('low')
            self.low = value
        super(t_junction_priority, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_junction_priority, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_junction_priority


class t_junction_surface(_OpenDriveElement):
    """t_junction_surface -- Used to describe the road elevation profile within a junction. When a
    <
    junction
    >
    element contains a
    <
    surface
    >
    element, the
    <
    surface
    >
    element supersedes all elevation data for connecting roads.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, CRG=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_junction_surface"), self).__init__( **kwargs_)
        if CRG is None:
            self.CRG = []
        else:
            self.CRG = CRG
        self.CRG_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_surface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_surface.subclass:
            return t_junction_surface.subclass(*args_, **kwargs_)
        else:
            return t_junction_surface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.CRG or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_junction_surface, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_surface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_surface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_junction_surface':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_surface')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_surface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_surface'):
        super(t_junction_surface, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_surface')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_surface', fromsubclass_=False, pretty_print=True):
        super(t_junction_surface, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CRG_ in self.CRG:
            namespaceprefix_ = self.CRG_nsprefix_ + ':' if (UseCapturedNS_ and self.CRG_nsprefix_) else ''
            CRG_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CRG', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_junction_surface, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CRG':
            obj_ = t_junction_surface_CRG.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CRG.append(obj_)
            obj_.original_tagname_ = 'CRG'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_junction_surface, self)._buildChildren(child_, node, nodeName_, True)
# end class t_junction_surface


class t_junction_surface_CRG(_OpenDriveElement):
    """t_junction_surface_CRG -- Data described in OpenCRG are represented by the
    <
    CRG
    >
    element within the
    <
    surface
    >
    element.
    file -- Name of the file containing the CRG data
    mode -- Attachment mode for the surface data.
    purpose -- Physical purpose of the data contained in the CRG file; if the attribute is missing, data will be interpreted as elevation data.
    zOffset -- z offset between CRG center line and inertial xy-plane
    (default = 0.0)
    zScale -- z scale factor for the surface description (default = 1.0)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, file=None, mode='global', purpose=None, zOffset=None, zScale=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_junction_surface_CRG"), self).__init__( **kwargs_)
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
        self.mode = _cast(None, mode)
        self.mode_nsprefix_ = None
        self.purpose = _cast(None, purpose)
        self.purpose_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.zScale = _cast(float, zScale)
        self.zScale_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junction_surface_CRG)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junction_surface_CRG.subclass:
            return t_junction_surface_CRG.subclass(*args_, **kwargs_)
        else:
            return t_junction_surface_CRG(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_junction_surface_CRG_mode(self, value):
        # Validate type e_junction_surface_CRG_mode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['global']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_junction_surface_CRG_mode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_road_surface_CRG_purpose(self, value):
        # Validate type e_road_surface_CRG_purpose, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['elevation', 'friction']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_road_surface_CRG_purpose' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_junction_surface_CRG, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_surface_CRG', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junction_surface_CRG')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_junction_surface_CRG':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_surface_CRG')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junction_surface_CRG', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junction_surface_CRG'):
        super(t_junction_surface_CRG, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junction_surface_CRG')
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mode), input_name='mode')), ))
        if self.purpose is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            outfile.write(' purpose=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.purpose), input_name='purpose')), ))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if self.zScale is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            outfile.write(' zScale="%s"' % self.gds_format_double(self.zScale, input_name='zScale'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junction_surface_CRG', fromsubclass_=False, pretty_print=True):
        super(t_junction_surface_CRG, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
            self.validate_e_junction_surface_CRG_mode(self.mode)    # validate type e_junction_surface_CRG_mode
        value = find_attr_value_('purpose', node)
        if value is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            self.purpose = value
            self.validate_e_road_surface_CRG_purpose(self.purpose)    # validate type e_road_surface_CRG_purpose
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            value = self.gds_parse_double(value, node, 'zOffset')
            self.zOffset = value
        value = find_attr_value_('zScale', node)
        if value is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            value = self.gds_parse_double(value, node, 'zScale')
            self.zScale = value
        super(t_junction_surface_CRG, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_junction_surface_CRG, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_junction_surface_CRG


class t_junctionGroup(_OpenDriveElement):
    """t_junctionGroup -- Two or more junctions may be grouped in junction groups to indicate that these junctions belong to the same roundabout.
    The
    <
    junctionGroup
    >
    element is split into a header element and a series of member elements.
    id -- Unique ID within database
    name -- Name of the junction group. May be chosen freely.
    type -- Type of junction group
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, name=None, type_=None, junctionReference=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_junctionGroup"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if junctionReference is None:
            self.junctionReference = []
        else:
            self.junctionReference = junctionReference
        self.junctionReference_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junctionGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junctionGroup.subclass:
            return t_junctionGroup.subclass(*args_, **kwargs_)
        else:
            return t_junctionGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_junctionGroup_type(self, value):
        # Validate type e_junctionGroup_type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['roundabout', 'unknown']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_junctionGroup_type' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.junctionReference or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_junctionGroup, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junctionGroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junctionGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_junctionGroup':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junctionGroup')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junctionGroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junctionGroup'):
        super(t_junctionGroup, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junctionGroup')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junctionGroup', fromsubclass_=False, pretty_print=True):
        super(t_junctionGroup, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for junctionReference_ in self.junctionReference:
            namespaceprefix_ = self.junctionReference_nsprefix_ + ':' if (UseCapturedNS_ and self.junctionReference_nsprefix_) else ''
            junctionReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='junctionReference', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_junctionGroup_type(self.type_)    # validate type e_junctionGroup_type
        super(t_junctionGroup, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'junctionReference':
            obj_ = t_junctionGroup_junctionReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.junctionReference.append(obj_)
            obj_.original_tagname_ = 'junctionReference'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_junctionGroup, self)._buildChildren(child_, node, nodeName_, True)
# end class t_junctionGroup


class t_junctionGroup_junctionReference(_OpenDriveElement):
    """t_junctionGroup_junctionReference -- References to existing
    <
    junction
    >
    elements.
    junction -- ID of the junction
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, junction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_junctionGroup_junctionReference"), self).__init__( **kwargs_)
        self.junction = _cast(None, junction)
        self.junction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_junctionGroup_junctionReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_junctionGroup_junctionReference.subclass:
            return t_junctionGroup_junctionReference.subclass(*args_, **kwargs_)
        else:
            return t_junctionGroup_junctionReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_junctionGroup_junctionReference, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junctionGroup_junctionReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_junctionGroup_junctionReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_junctionGroup_junctionReference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junctionGroup_junctionReference')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_junctionGroup_junctionReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_junctionGroup_junctionReference'):
        super(t_junctionGroup_junctionReference, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_junctionGroup_junctionReference')
        if self.junction is not None and 'junction' not in already_processed:
            already_processed.add('junction')
            outfile.write(' junction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.junction), input_name='junction')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_junctionGroup_junctionReference', fromsubclass_=False, pretty_print=True):
        super(t_junctionGroup_junctionReference, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('junction', node)
        if value is not None and 'junction' not in already_processed:
            already_processed.add('junction')
            self.junction = value
        super(t_junctionGroup_junctionReference, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_junctionGroup_junctionReference, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_junctionGroup_junctionReference


class t_controller(_OpenDriveElement):
    """t_controller -- Controllers provides identical states for one or more dynamic signals. Controllers serve as wrappers for the behaviour of a group of signals. Controllers are used for dynamic speed control on motorways, and to control traffic light switching phases.
    id -- Unique ID within database
    name -- Name of the controller. May be chosen freely.
    sequence -- Sequence number (priority) of this controller with respect to other controllers of same logical level
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, name=None, sequence=None, control=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_controller"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        if control is None:
            self.control = []
        else:
            self.control = control
        self.control_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_controller)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_controller.subclass:
            return t_controller.subclass(*args_, **kwargs_)
        else:
            return t_controller(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.control or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_controller, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_controller', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_controller')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_controller':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_controller')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_controller', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_controller'):
        super(t_controller, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_controller')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_controller', fromsubclass_=False, pretty_print=True):
        super(t_controller, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            namespaceprefix_ = self.control_nsprefix_ + ':' if (UseCapturedNS_ and self.control_nsprefix_) else ''
            control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='control', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
            if self.sequence < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        super(t_controller, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'control':
            obj_ = t_controller_control.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_controller, self)._buildChildren(child_, node, nodeName_, True)
# end class t_controller


class t_controller_control(_OpenDriveElement):
    """t_controller_control -- Provides information about a single signal controlled by the corresponding controller.
    signalId -- ID of the controlled signal
    type -- Type of control.
    Free Text, depends on the application.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, signalId=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_controller_control"), self).__init__( **kwargs_)
        self.signalId = _cast(None, signalId)
        self.signalId_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_controller_control)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_controller_control.subclass:
            return t_controller_control.subclass(*args_, **kwargs_)
        else:
            return t_controller_control(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_controller_control, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_controller_control', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_controller_control')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_controller_control':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_controller_control')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_controller_control', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_controller_control'):
        super(t_controller_control, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_controller_control')
        if self.signalId is not None and 'signalId' not in already_processed:
            already_processed.add('signalId')
            outfile.write(' signalId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.signalId), input_name='signalId')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_controller_control', fromsubclass_=False, pretty_print=True):
        super(t_controller_control, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('signalId', node)
        if value is not None and 'signalId' not in already_processed:
            already_processed.add('signalId')
            self.signalId = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(t_controller_control, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_controller_control, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_controller_control


class t_road_signals(_OpenDriveElement):
    """t_road_signals -- The
    <
    signals
    >
    element is the container for all signals along a road.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, signal=None, signalReference=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_signals"), self).__init__( **kwargs_)
        if signal is None:
            self.signal = []
        else:
            self.signal = signal
        self.signal_nsprefix_ = None
        if signalReference is None:
            self.signalReference = []
        else:
            self.signalReference = signalReference
        self.signalReference_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals.subclass:
            return t_road_signals.subclass(*args_, **kwargs_)
        else:
            return t_road_signals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.signal or
            self.signalReference or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_signals, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_signals':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals'):
        super(t_road_signals, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals', fromsubclass_=False, pretty_print=True):
        super(t_road_signals, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for signal_ in self.signal:
            namespaceprefix_ = self.signal_nsprefix_ + ':' if (UseCapturedNS_ and self.signal_nsprefix_) else ''
            signal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signal', pretty_print=pretty_print)
        for signalReference_ in self.signalReference:
            namespaceprefix_ = self.signalReference_nsprefix_ + ':' if (UseCapturedNS_ and self.signalReference_nsprefix_) else ''
            signalReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signalReference', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_signals, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'signal':
            obj_ = t_road_signals_signal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signal.append(obj_)
            obj_.original_tagname_ = 'signal'
        elif nodeName_ == 'signalReference':
            obj_ = t_road_signals_signalReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signalReference.append(obj_)
            obj_.original_tagname_ = 'signalReference'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_signals, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_signals


class t_road_signals_signal(_OpenDriveElement):
    """t_road_signals_signal -- Used to provide information about signals along a road. Consists of a main element and an optional lane validity element. The element for a signal is
    <
    signal
    >
    .
    country -- Country code of the road, see ISO 3166-1, alpha-2 codes.
    countryRevision -- Defines the year of the applied traffic rules
    dynamic -- Indicates whether the signal is dynamic or static. Example: traffic light is dynamic
    height -- Height of the signal, measured from bottom edge of the signal
    hOffset -- Heading offset of the signal (relative to @orientation, if orientation is equal to
    “
    +
    ”
    or
    “
    -
    “
    )
    Heading offset of the signal (relative to reference line, if orientation is equal to
    “
    none
    ”
    )
    id -- Unique ID of the signal within the OpenDRIVE file
    name -- Name of the signal. May be chosen freely.
    orientation -- "+" = valid in positive s- direction
    "-" = valid in negative s- direction
    "none" = valid in both directions
    pitch -- Pitch angle of the signal, relative to the inertial system (xy-plane)
    roll -- Roll angle of the signal after applying pitch, relative to the inertial system (x
    ’
    ’
    y
    ’
    ’
    -plane)
    s -- s-coordinate
    subtype -- Subtype identifier according to country code or "-1" / "none"
    t -- t-coordinate
    text -- Additional text associated with the signal, for example, text on city limit "City\nBadAibling"
    type -- Type identifier according to country code
    or "-1" / "none". See extra document.
    unit -- Unit of @value
    value -- Value of the signal, if value is given, unit is mandatory
    width -- Width of the signal
    zOffset -- z offset from the road to bottom edge of the signal. This represents the vertical clearance of the object. Relative to the reference line.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, country=None, countryRevision=None, dynamic=None, height=None, hOffset=None, id=None, name=None, orientation=None, pitch=None, roll=None, s=None, subtype=None, t=None, text=None, type_=None, unit=None, value=None, width=None, zOffset=None, validity=None, dependency=None, reference=None, positionInertial=None, positionRoad=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_signals_signal"), self).__init__( **kwargs_)
        self.country = _cast(None, country)
        self.country_nsprefix_ = None
        self.countryRevision = _cast(None, countryRevision)
        self.countryRevision_nsprefix_ = None
        self.dynamic = _cast(None, dynamic)
        self.dynamic_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.hOffset = _cast(float, hOffset)
        self.hOffset_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.pitch = _cast(float, pitch)
        self.pitch_nsprefix_ = None
        self.roll = _cast(float, roll)
        self.roll_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.subtype = _cast(None, subtype)
        self.subtype_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.value = _cast(float, value)
        self.value_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if dependency is None:
            self.dependency = []
        else:
            self.dependency = dependency
        self.dependency_nsprefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
        self.positionInertial = positionInertial
        self.positionInertial_nsprefix_ = None
        self.positionRoad = positionRoad
        self.positionRoad_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signal.subclass:
            return t_road_signals_signal.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_countryCode(self, value):
        # Validate type e_countryCode, a restriction on None.
        pass
    def validate_t_yesNo(self, value):
        # Validate type t_yesNo, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on t_yesNo' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_orientation(self, value):
        # Validate type e_orientation, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_orientation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_unit(self, value):
        # Validate type e_unit, a restriction on None.
        pass
    def has__content(self):
        if (
            self.validity or
            self.dependency or
            self.reference or
            self.positionInertial is not None or
            self.positionRoad is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_signals_signal, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_signals_signal':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signal'):
        super(t_road_signals_signal, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal')
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            outfile.write(' country=%s' % (quote_attrib(self.country), ))
        if self.countryRevision is not None and 'countryRevision' not in already_processed:
            already_processed.add('countryRevision')
            outfile.write(' countryRevision=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.countryRevision), input_name='countryRevision')), ))
        if self.dynamic is not None and 'dynamic' not in already_processed:
            already_processed.add('dynamic')
            outfile.write(' dynamic=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dynamic), input_name='dynamic')), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.hOffset is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            outfile.write(' hOffset="%s"' % self.gds_format_double(self.hOffset, input_name='hOffset'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if self.pitch is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            outfile.write(' pitch="%s"' % self.gds_format_double(self.pitch, input_name='pitch'))
        if self.roll is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            outfile.write(' roll="%s"' % self.gds_format_double(self.roll, input_name='roll'))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.subtype is not None and 'subtype' not in already_processed:
            already_processed.add('subtype')
            outfile.write(' subtype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.subtype), input_name='subtype')), ))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal', fromsubclass_=False, pretty_print=True):
        super(t_road_signals_signal, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for dependency_ in self.dependency:
            namespaceprefix_ = self.dependency_nsprefix_ + ':' if (UseCapturedNS_ and self.dependency_nsprefix_) else ''
            dependency_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dependency', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.positionInertial is not None:
            namespaceprefix_ = self.positionInertial_nsprefix_ + ':' if (UseCapturedNS_ and self.positionInertial_nsprefix_) else ''
            self.positionInertial.export(outfile, level, namespaceprefix_, namespacedef_='', name_='positionInertial', pretty_print=pretty_print)
        if self.positionRoad is not None:
            namespaceprefix_ = self.positionRoad_nsprefix_ + ':' if (UseCapturedNS_ and self.positionRoad_nsprefix_) else ''
            self.positionRoad.export(outfile, level, namespaceprefix_, namespacedef_='', name_='positionRoad', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('country', node)
        if value is not None and 'country' not in already_processed:
            already_processed.add('country')
            self.country = value
            self.validate_e_countryCode(self.country)    # validate type e_countryCode
        value = find_attr_value_('countryRevision', node)
        if value is not None and 'countryRevision' not in already_processed:
            already_processed.add('countryRevision')
            self.countryRevision = value
        value = find_attr_value_('dynamic', node)
        if value is not None and 'dynamic' not in already_processed:
            already_processed.add('dynamic')
            self.dynamic = value
            self.validate_t_yesNo(self.dynamic)    # validate type t_yesNo
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_double(value, node, 'height')
            self.height = value
            self.validate_t_grEqZero(self.height)    # validate type t_grEqZero
        value = find_attr_value_('hOffset', node)
        if value is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            value = self.gds_parse_double(value, node, 'hOffset')
            self.hOffset = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_e_orientation(self.orientation)    # validate type e_orientation
        value = find_attr_value_('pitch', node)
        if value is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            value = self.gds_parse_double(value, node, 'pitch')
            self.pitch = value
        value = find_attr_value_('roll', node)
        if value is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            value = self.gds_parse_double(value, node, 'roll')
            self.roll = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('subtype', node)
        if value is not None and 'subtype' not in already_processed:
            already_processed.add('subtype')
            self.subtype = value
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_e_unit(self.unit)    # validate type e_unit
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            value = self.gds_parse_double(value, node, 'value')
            self.value = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
            self.validate_t_grEqZero(self.width)    # validate type t_grEqZero
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            value = self.gds_parse_double(value, node, 'zOffset')
            self.zOffset = value
        super(t_road_signals_signal, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'dependency':
            obj_ = t_road_signals_signal_dependency.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dependency.append(obj_)
            obj_.original_tagname_ = 'dependency'
        elif nodeName_ == 'reference':
            obj_ = t_road_signals_signal_reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'positionInertial':
            obj_ = t_road_signals_signal_positionInertial.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionInertial = obj_
            obj_.original_tagname_ = 'positionInertial'
        elif nodeName_ == 'positionRoad':
            obj_ = t_road_signals_signal_positionRoad.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionRoad = obj_
            obj_.original_tagname_ = 'positionRoad'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_signals_signal, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_signals_signal


class t_road_signals_signal_dependency(_OpenDriveElement):
    """t_road_signals_signal_dependency -- Signal dependency means that one signal controls the output of another signal. A signal may have multiple dependency elements.
    id -- ID of the controlling signal
    type -- Type of the dependency,
    Free text, depending on application
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_signals_signal_dependency"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signal_dependency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signal_dependency.subclass:
            return t_road_signals_signal_dependency.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signal_dependency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_signals_signal_dependency, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_dependency', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signal_dependency')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_signals_signal_dependency':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_dependency')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signal_dependency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signal_dependency'):
        super(t_road_signals_signal_dependency, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_dependency')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_dependency', fromsubclass_=False, pretty_print=True):
        super(t_road_signals_signal_dependency, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(t_road_signals_signal_dependency, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_signals_signal_dependency, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_signals_signal_dependency


class t_road_signals_signal_positionInertial(_OpenDriveElement):
    """t_road_signals_signal_positionInertial -- Describes the reference point of the physical position in inertial coordinates in cases where it deviates from the logical position. Defines the inertial position.
    hdg -- Heading of the signal, relative to the inertial system
    pitch -- Pitch angle of the signal after applying heading, relative to the inertial system (x
    ’
    y
    ’
    -plane)
    roll -- Roll angle of the signal after applying heading and pitch, relative to the inertial system (x
    ’
    ’
    y
    ’
    ’
    -plane)
    x -- x-coordinate
    y -- y-coordinate
    z -- z-coordinate
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, hdg=None, pitch=None, roll=None, x=None, y=None, z=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_signals_signal_positionInertial"), self).__init__( **kwargs_)
        self.hdg = _cast(float, hdg)
        self.hdg_nsprefix_ = None
        self.pitch = _cast(float, pitch)
        self.pitch_nsprefix_ = None
        self.roll = _cast(float, roll)
        self.roll_nsprefix_ = None
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signal_positionInertial)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signal_positionInertial.subclass:
            return t_road_signals_signal_positionInertial.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signal_positionInertial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_signals_signal_positionInertial, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_positionInertial', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signal_positionInertial')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_signals_signal_positionInertial':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_positionInertial')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signal_positionInertial', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signal_positionInertial'):
        super(t_road_signals_signal_positionInertial, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_positionInertial')
        if self.hdg is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            outfile.write(' hdg="%s"' % self.gds_format_double(self.hdg, input_name='hdg'))
        if self.pitch is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            outfile.write(' pitch="%s"' % self.gds_format_double(self.pitch, input_name='pitch'))
        if self.roll is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            outfile.write(' roll="%s"' % self.gds_format_double(self.roll, input_name='roll'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_positionInertial', fromsubclass_=False, pretty_print=True):
        super(t_road_signals_signal_positionInertial, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hdg', node)
        if value is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            value = self.gds_parse_double(value, node, 'hdg')
            self.hdg = value
        value = find_attr_value_('pitch', node)
        if value is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            value = self.gds_parse_double(value, node, 'pitch')
            self.pitch = value
        value = find_attr_value_('roll', node)
        if value is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            value = self.gds_parse_double(value, node, 'roll')
            self.roll = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            value = self.gds_parse_double(value, node, 'x')
            self.x = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            value = self.gds_parse_double(value, node, 'y')
            self.y = value
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            value = self.gds_parse_double(value, node, 'z')
            self.z = value
        super(t_road_signals_signal_positionInertial, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_signals_signal_positionInertial, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_signals_signal_positionInertial


class t_road_signals_signal_positionRoad(_OpenDriveElement):
    """t_road_signals_signal_positionRoad -- Describes the reference point of the physical position road coordinates in cases where it deviates from the logical position. Defines the position on the road.
    hOffset -- Heading offset of the signal (relative to @orientation)
    pitch -- Pitch angle of the signal after applying hOffset, relative to the inertial system (x
    ’
    y
    ’
    -plane)
    roadId -- Unique ID of the referenced road
    roll -- Roll angle of the signal after applying hOffset and pitch, relative to the inertial system (x
    ’
    ’
    y
    ’
    ’
    -plane)
    s -- s-coordinate
    t -- t-coordinate
    zOffset -- z offset from road level to bottom edge of the signal
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, hOffset=None, pitch=None, roadId=None, roll=None, s=None, t=None, zOffset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_signals_signal_positionRoad"), self).__init__( **kwargs_)
        self.hOffset = _cast(float, hOffset)
        self.hOffset_nsprefix_ = None
        self.pitch = _cast(float, pitch)
        self.pitch_nsprefix_ = None
        self.roadId = _cast(None, roadId)
        self.roadId_nsprefix_ = None
        self.roll = _cast(float, roll)
        self.roll_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signal_positionRoad)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signal_positionRoad.subclass:
            return t_road_signals_signal_positionRoad.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signal_positionRoad(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_signals_signal_positionRoad, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_positionRoad', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signal_positionRoad')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_signals_signal_positionRoad':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_positionRoad')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signal_positionRoad', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signal_positionRoad'):
        super(t_road_signals_signal_positionRoad, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_positionRoad')
        if self.hOffset is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            outfile.write(' hOffset="%s"' % self.gds_format_double(self.hOffset, input_name='hOffset'))
        if self.pitch is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            outfile.write(' pitch="%s"' % self.gds_format_double(self.pitch, input_name='pitch'))
        if self.roadId is not None and 'roadId' not in already_processed:
            already_processed.add('roadId')
            outfile.write(' roadId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.roadId), input_name='roadId')), ))
        if self.roll is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            outfile.write(' roll="%s"' % self.gds_format_double(self.roll, input_name='roll'))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_positionRoad', fromsubclass_=False, pretty_print=True):
        super(t_road_signals_signal_positionRoad, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hOffset', node)
        if value is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            value = self.gds_parse_double(value, node, 'hOffset')
            self.hOffset = value
        value = find_attr_value_('pitch', node)
        if value is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            value = self.gds_parse_double(value, node, 'pitch')
            self.pitch = value
        value = find_attr_value_('roadId', node)
        if value is not None and 'roadId' not in already_processed:
            already_processed.add('roadId')
            self.roadId = value
        value = find_attr_value_('roll', node)
        if value is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            value = self.gds_parse_double(value, node, 'roll')
            self.roll = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            value = self.gds_parse_double(value, node, 'zOffset')
            self.zOffset = value
        super(t_road_signals_signal_positionRoad, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_signals_signal_positionRoad, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_signals_signal_positionRoad


class t_road_signals_signal_reference(_OpenDriveElement):
    """t_road_signals_signal_reference -- Provides a means to link a signal to a series of other elements (for example, objects and signals).
    elementId -- Unique ID of the linked element
    elementType -- Type of the linked element
    type -- Type of the linkage
    Free text, depending on application
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, elementId=None, elementType=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_signals_signal_reference"), self).__init__( **kwargs_)
        self.elementId = _cast(None, elementId)
        self.elementId_nsprefix_ = None
        self.elementType = _cast(None, elementType)
        self.elementType_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signal_reference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signal_reference.subclass:
            return t_road_signals_signal_reference.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signal_reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_road_signals_signal_reference_elementType(self, value):
        # Validate type e_road_signals_signal_reference_elementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['object', 'signal']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_road_signals_signal_reference_elementType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_signals_signal_reference, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_reference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signal_reference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_signals_signal_reference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_reference')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signal_reference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signal_reference'):
        super(t_road_signals_signal_reference, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signal_reference')
        if self.elementId is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            outfile.write(' elementId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementId), input_name='elementId')), ))
        if self.elementType is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            outfile.write(' elementType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementType), input_name='elementType')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signal_reference', fromsubclass_=False, pretty_print=True):
        super(t_road_signals_signal_reference, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('elementId', node)
        if value is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            self.elementId = value
        value = find_attr_value_('elementType', node)
        if value is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            self.elementType = value
            self.validate_e_road_signals_signal_reference_elementType(self.elementType)    # validate type e_road_signals_signal_reference_elementType
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(t_road_signals_signal_reference, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_signals_signal_reference, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_signals_signal_reference


class t_road_signals_signalReference(_OpenDriveElement):
    """t_road_signals_signalReference -- Refers to the same, that is, identical signal from multiple roads. The referenced signals require a unique ID. The
    <
    signalReference
    >
    element consists of a main element and an optional lane validity element.
    id -- Unique ID of the referenced signal within the database
    orientation -- "+" = valid in positive s-direction
    "-" = valid in negative s-direction
    "none" = valid in both directions
    s -- s-coordinate
    t -- t-coordinate
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, orientation=None, s=None, t=None, validity=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_signals_signalReference"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_signals_signalReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_signals_signalReference.subclass:
            return t_road_signals_signalReference.subclass(*args_, **kwargs_)
        else:
            return t_road_signals_signalReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_orientation(self, value):
        # Validate type e_orientation, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_orientation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.validity or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_signals_signalReference, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signalReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_signals_signalReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_signals_signalReference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signalReference')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_signals_signalReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_signals_signalReference'):
        super(t_road_signals_signalReference, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_signals_signalReference')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_signals_signalReference', fromsubclass_=False, pretty_print=True):
        super(t_road_signals_signalReference, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_e_orientation(self.orientation)    # validate type e_orientation
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        super(t_road_signals_signalReference, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_signals_signalReference, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_signals_signalReference


class t_road(_OpenDriveElement):
    """t_road -- In ASAM OpenDRIVE, the road network is represented by
    <
    road
    >
    elements. Each road runs along one road reference line. A road shall have at least one lane with a width larger than 0. Vehicles may drive in both directions of the reference line. The standard driving direction is defined by the value which is assigned to the @rule attribute (RHT=right-hand traffic, LHT=left-hand traffic).
    ASAM OpenDRIVE roads may be roads in the real road network or artificial road network created for application use. Each road is described by one or more
    <
    road
    >
    elements. One
    <
    road
    >
    element may cover a long stretch of a road, shorter stretches between junctions, or even several roads. A new
    <
    road
    >
    element should only start if the properties of the road cannot be described within the previous
    <
    road
    >
    element or if a junction is required.
    id -- Unique ID within the database. If it represents an integer number, it should comply to uint32_t and stay within the given range.
    junction -- ID of the junction to which the road belongs as a connecting road (= -1 for none)
    length -- Total length of the reference line in the xy-plane. Change in length due to elevation is not considered
    name -- Name of the road. May be chosen freely.
    rule -- Basic rule for using the road; RHT=right-hand traffic, LHT=left-hand traffic. When this attribute is missing, RHT is assumed.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, junction=None, length=None, name=None, rule=None, link=None, type_=None, planView=None, elevationProfile=None, lateralProfile=None, lanes=None, objects=None, signals=None, surface=None, railroad=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.junction = _cast(None, junction)
        self.junction_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.rule = _cast(None, rule)
        self.rule_nsprefix_ = None
        self.link = link
        self.link_nsprefix_ = None
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        self.type__nsprefix_ = None
        self.planView = planView
        self.planView_nsprefix_ = None
        self.elevationProfile = elevationProfile
        self.elevationProfile_nsprefix_ = None
        self.lateralProfile = lateralProfile
        self.lateralProfile_nsprefix_ = None
        self.lanes = lanes
        self.lanes_nsprefix_ = None
        self.objects = objects
        self.objects_nsprefix_ = None
        self.signals = signals
        self.signals_nsprefix_ = None
        self.surface = surface
        self.surface_nsprefix_ = None
        self.railroad = railroad
        self.railroad_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road.subclass:
            return t_road.subclass(*args_, **kwargs_)
        else:
            return t_road(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grZero(self, value):
        # Validate type t_grZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on t_grZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_trafficRule(self, value):
        # Validate type e_trafficRule, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RHT', 'LHT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_trafficRule' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.link is not None or
            self.type_ or
            self.planView is not None or
            self.elevationProfile is not None or
            self.lateralProfile is not None or
            self.lanes is not None or
            self.objects is not None or
            self.signals is not None or
            self.surface is not None or
            self.railroad is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road'):
        super(t_road, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.junction is not None and 'junction' not in already_processed:
            already_processed.add('junction')
            outfile.write(' junction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.junction), input_name='junction')), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.rule is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            outfile.write(' rule=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rule), input_name='rule')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road', fromsubclass_=False, pretty_print=True):
        super(t_road, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.link is not None:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            self.link.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for type_ in self.type_:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        if self.planView is not None:
            namespaceprefix_ = self.planView_nsprefix_ + ':' if (UseCapturedNS_ and self.planView_nsprefix_) else ''
            self.planView.export(outfile, level, namespaceprefix_, namespacedef_='', name_='planView', pretty_print=pretty_print)
        if self.elevationProfile is not None:
            namespaceprefix_ = self.elevationProfile_nsprefix_ + ':' if (UseCapturedNS_ and self.elevationProfile_nsprefix_) else ''
            self.elevationProfile.export(outfile, level, namespaceprefix_, namespacedef_='', name_='elevationProfile', pretty_print=pretty_print)
        if self.lateralProfile is not None:
            namespaceprefix_ = self.lateralProfile_nsprefix_ + ':' if (UseCapturedNS_ and self.lateralProfile_nsprefix_) else ''
            self.lateralProfile.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lateralProfile', pretty_print=pretty_print)
        if self.lanes is not None:
            namespaceprefix_ = self.lanes_nsprefix_ + ':' if (UseCapturedNS_ and self.lanes_nsprefix_) else ''
            self.lanes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lanes', pretty_print=pretty_print)
        if self.objects is not None:
            namespaceprefix_ = self.objects_nsprefix_ + ':' if (UseCapturedNS_ and self.objects_nsprefix_) else ''
            self.objects.export(outfile, level, namespaceprefix_, namespacedef_='', name_='objects', pretty_print=pretty_print)
        if self.signals is not None:
            namespaceprefix_ = self.signals_nsprefix_ + ':' if (UseCapturedNS_ and self.signals_nsprefix_) else ''
            self.signals.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signals', pretty_print=pretty_print)
        if self.surface is not None:
            namespaceprefix_ = self.surface_nsprefix_ + ':' if (UseCapturedNS_ and self.surface_nsprefix_) else ''
            self.surface.export(outfile, level, namespaceprefix_, namespacedef_='', name_='surface', pretty_print=pretty_print)
        if self.railroad is not None:
            namespaceprefix_ = self.railroad_nsprefix_ + ':' if (UseCapturedNS_ and self.railroad_nsprefix_) else ''
            self.railroad.export(outfile, level, namespaceprefix_, namespacedef_='', name_='railroad', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('junction', node)
        if value is not None and 'junction' not in already_processed:
            already_processed.add('junction')
            self.junction = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
            self.validate_t_grZero(self.length)    # validate type t_grZero
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('rule', node)
        if value is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            self.rule = value
            self.validate_e_trafficRule(self.rule)    # validate type e_trafficRule
        super(t_road, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'link':
            obj_ = t_road_link.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.link = obj_
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'type':
            obj_ = t_road_type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'planView':
            obj_ = t_road_planView.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.planView = obj_
            obj_.original_tagname_ = 'planView'
        elif nodeName_ == 'elevationProfile':
            obj_ = t_road_elevationProfile.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.elevationProfile = obj_
            obj_.original_tagname_ = 'elevationProfile'
        elif nodeName_ == 'lateralProfile':
            obj_ = t_road_lateralProfile.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lateralProfile = obj_
            obj_.original_tagname_ = 'lateralProfile'
        elif nodeName_ == 'lanes':
            obj_ = t_road_lanes.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lanes = obj_
            obj_.original_tagname_ = 'lanes'
        elif nodeName_ == 'objects':
            obj_ = t_road_objects.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.objects = obj_
            obj_.original_tagname_ = 'objects'
        elif nodeName_ == 'signals':
            obj_ = t_road_signals.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signals = obj_
            obj_.original_tagname_ = 'signals'
        elif nodeName_ == 'surface':
            obj_ = t_road_surface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.surface = obj_
            obj_.original_tagname_ = 'surface'
        elif nodeName_ == 'railroad':
            obj_ = t_road_railroad.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.railroad = obj_
            obj_.original_tagname_ = 'railroad'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road


class t_road_elevationProfile(_OpenDriveElement):
    """t_road_elevationProfile -- Defines the characteristics of the road elevation along the reference line.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, elevation=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_elevationProfile"), self).__init__( **kwargs_)
        if elevation is None:
            self.elevation = []
        else:
            self.elevation = elevation
        self.elevation_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_elevationProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_elevationProfile.subclass:
            return t_road_elevationProfile.subclass(*args_, **kwargs_)
        else:
            return t_road_elevationProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.elevation or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_elevationProfile, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_elevationProfile', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_elevationProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_elevationProfile':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_elevationProfile')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_elevationProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_elevationProfile'):
        super(t_road_elevationProfile, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_elevationProfile')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_elevationProfile', fromsubclass_=False, pretty_print=True):
        super(t_road_elevationProfile, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for elevation_ in self.elevation:
            namespaceprefix_ = self.elevation_nsprefix_ + ':' if (UseCapturedNS_ and self.elevation_nsprefix_) else ''
            elevation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='elevation', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_elevationProfile, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'elevation':
            obj_ = t_road_elevationProfile_elevation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.elevation.append(obj_)
            obj_.original_tagname_ = 'elevation'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_elevationProfile, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_elevationProfile


class t_road_elevationProfile_elevation(_OpenDriveElement):
    """t_road_elevationProfile_elevation -- Defines an elevation element at a given position on the reference line. Elements shall be defined in ascending order along the reference line. The s length does not change with the elevation.
    a -- Polynom parameter a, elevation at @s (ds=0)
    b -- Polynom parameter b
    c -- Polynom parameter c
    d -- Polynom parameter d
    s -- s-coordinate of start position
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, a=None, b=None, c=None, d=None, s=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_elevationProfile_elevation"), self).__init__( **kwargs_)
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_elevationProfile_elevation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_elevationProfile_elevation.subclass:
            return t_road_elevationProfile_elevation.subclass(*args_, **kwargs_)
        else:
            return t_road_elevationProfile_elevation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_elevationProfile_elevation, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_elevationProfile_elevation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_elevationProfile_elevation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_elevationProfile_elevation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_elevationProfile_elevation')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_elevationProfile_elevation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_elevationProfile_elevation'):
        super(t_road_elevationProfile_elevation, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_elevationProfile_elevation')
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_elevationProfile_elevation', fromsubclass_=False, pretty_print=True):
        super(t_road_elevationProfile_elevation, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        super(t_road_elevationProfile_elevation, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_elevationProfile_elevation, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_elevationProfile_elevation


class t_road_lateralProfile(_OpenDriveElement):
    """t_road_lateralProfile -- Contains a series of superelevation elements that define the characteristics of the road surface's banking along the reference line.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, superelevation=None, shape=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lateralProfile"), self).__init__( **kwargs_)
        if superelevation is None:
            self.superelevation = []
        else:
            self.superelevation = superelevation
        self.superelevation_nsprefix_ = None
        if shape is None:
            self.shape = []
        else:
            self.shape = shape
        self.shape_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lateralProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lateralProfile.subclass:
            return t_road_lateralProfile.subclass(*args_, **kwargs_)
        else:
            return t_road_lateralProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.superelevation or
            self.shape or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_lateralProfile, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lateralProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lateralProfile':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lateralProfile')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lateralProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lateralProfile'):
        super(t_road_lateralProfile, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lateralProfile')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile', fromsubclass_=False, pretty_print=True):
        super(t_road_lateralProfile, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for superelevation_ in self.superelevation:
            namespaceprefix_ = self.superelevation_nsprefix_ + ':' if (UseCapturedNS_ and self.superelevation_nsprefix_) else ''
            superelevation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superelevation', pretty_print=pretty_print)
        for shape_ in self.shape:
            namespaceprefix_ = self.shape_nsprefix_ + ':' if (UseCapturedNS_ and self.shape_nsprefix_) else ''
            shape_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shape', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_lateralProfile, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'superelevation':
            obj_ = t_road_lateralProfile_superelevation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.superelevation.append(obj_)
            obj_.original_tagname_ = 'superelevation'
        elif nodeName_ == 'shape':
            obj_ = t_road_lateralProfile_shape.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shape.append(obj_)
            obj_.original_tagname_ = 'shape'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_lateralProfile, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_lateralProfile


class t_road_lateralProfile_shape(_OpenDriveElement):
    """t_road_lateralProfile_shape -- Defined as the road section
    ’
    s surface relative to the reference plane. There may be several shape definitions at one s-position that have different t-values, thereby describing the curvy shape of the road.
    a -- Polynom parameter a, relative height at @t (dt=0)
    b -- Polynom parameter b
    c -- Polynom parameter c
    d -- Polynom parameter d
    s -- s-coordinate of start position
    t -- t-coordinate of start position
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, a=None, b=None, c=None, d=None, s=None, t=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lateralProfile_shape"), self).__init__( **kwargs_)
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lateralProfile_shape)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lateralProfile_shape.subclass:
            return t_road_lateralProfile_shape.subclass(*args_, **kwargs_)
        else:
            return t_road_lateralProfile_shape(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lateralProfile_shape, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile_shape', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lateralProfile_shape')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lateralProfile_shape':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lateralProfile_shape')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lateralProfile_shape', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lateralProfile_shape'):
        super(t_road_lateralProfile_shape, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lateralProfile_shape')
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile_shape', fromsubclass_=False, pretty_print=True):
        super(t_road_lateralProfile_shape, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        super(t_road_lateralProfile_shape, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lateralProfile_shape, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lateralProfile_shape


class t_road_lateralProfile_superelevation(_OpenDriveElement):
    """t_road_lateralProfile_superelevation -- Defined as the road section
    ’
    s roll angle around the s-axis. Elements must be defined in ascending order along the reference line. The parameters of an element are valid until the next element starts or the road reference line ends. Per default, the superelevation of a road is zero.
    a -- Polynom parameter a, superelevation at @s (ds=0)
    b -- Polynom parameter b
    c -- Polynom parameter c
    d -- Polynom parameter d
    s -- s-coordinate of start position
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, a=None, b=None, c=None, d=None, s=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lateralProfile_superelevation"), self).__init__( **kwargs_)
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lateralProfile_superelevation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lateralProfile_superelevation.subclass:
            return t_road_lateralProfile_superelevation.subclass(*args_, **kwargs_)
        else:
            return t_road_lateralProfile_superelevation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lateralProfile_superelevation, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile_superelevation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lateralProfile_superelevation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lateralProfile_superelevation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lateralProfile_superelevation')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lateralProfile_superelevation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lateralProfile_superelevation'):
        super(t_road_lateralProfile_superelevation, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lateralProfile_superelevation')
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lateralProfile_superelevation', fromsubclass_=False, pretty_print=True):
        super(t_road_lateralProfile_superelevation, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        super(t_road_lateralProfile_superelevation, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lateralProfile_superelevation, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lateralProfile_superelevation


class t_road_link(_OpenDriveElement):
    """t_road_link -- Follows the road header if the road is linked to a successor or a predecessor. Isolated roads may omit this element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, predecessor=None, successor=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_link"), self).__init__( **kwargs_)
        self.predecessor = predecessor
        self.predecessor_nsprefix_ = None
        self.successor = successor
        self.successor_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_link)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_link.subclass:
            return t_road_link.subclass(*args_, **kwargs_)
        else:
            return t_road_link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.predecessor is not None or
            self.successor is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_link, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_link', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_link')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_link':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_link')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_link', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_link'):
        super(t_road_link, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_link')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_link', fromsubclass_=False, pretty_print=True):
        super(t_road_link, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.predecessor is not None:
            namespaceprefix_ = self.predecessor_nsprefix_ + ':' if (UseCapturedNS_ and self.predecessor_nsprefix_) else ''
            self.predecessor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predecessor', pretty_print=pretty_print)
        if self.successor is not None:
            namespaceprefix_ = self.successor_nsprefix_ + ':' if (UseCapturedNS_ and self.successor_nsprefix_) else ''
            self.successor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='successor', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_link, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'predecessor':
            obj_ = t_road_link_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.predecessor = obj_
            obj_.original_tagname_ = 'predecessor'
        elif nodeName_ == 'successor':
            obj_ = t_road_link_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.successor = obj_
            obj_.original_tagname_ = 'successor'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_link, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_link


class t_road_link_predecessorSuccessor(_OpenDriveElement):
    """t_road_link_predecessorSuccessor -- Successors and predecessors can be junctions or roads. For each, different attribute sets shall be used.
    contactPoint -- Contact point of link on the linked element
    elementDir -- To be provided when elementS is used for the connection definition. Indicates the direction on the predecessor from which the road is entered.
    elementId -- ID of the linked element
    elementS -- Alternative to contactPoint for virtual junctions. Indicates a connection within the predecessor, meaning not at the start or end of the predecessor. Shall only be used for elementType "road"
    elementType -- Type of the linked element
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, contactPoint=None, elementDir=None, elementId=None, elementS=None, elementType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_link_predecessorSuccessor"), self).__init__( **kwargs_)
        self.contactPoint = _cast(None, contactPoint)
        self.contactPoint_nsprefix_ = None
        self.elementDir = _cast(None, elementDir)
        self.elementDir_nsprefix_ = None
        self.elementId = _cast(None, elementId)
        self.elementId_nsprefix_ = None
        self.elementS = _cast(float, elementS)
        self.elementS_nsprefix_ = None
        self.elementType = _cast(None, elementType)
        self.elementType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_link_predecessorSuccessor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_link_predecessorSuccessor.subclass:
            return t_road_link_predecessorSuccessor.subclass(*args_, **kwargs_)
        else:
            return t_road_link_predecessorSuccessor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_contactPoint(self, value):
        # Validate type e_contactPoint, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'end']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_contactPoint' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_elementDir(self, value):
        # Validate type e_elementDir, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_elementDir' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_road_link_elementType(self, value):
        # Validate type e_road_link_elementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['road', 'junction']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_road_link_elementType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_link_predecessorSuccessor, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_link_predecessorSuccessor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_link_predecessorSuccessor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_link_predecessorSuccessor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_link_predecessorSuccessor')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_link_predecessorSuccessor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_link_predecessorSuccessor'):
        super(t_road_link_predecessorSuccessor, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_link_predecessorSuccessor')
        if self.contactPoint is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            outfile.write(' contactPoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contactPoint), input_name='contactPoint')), ))
        if self.elementDir is not None and 'elementDir' not in already_processed:
            already_processed.add('elementDir')
            outfile.write(' elementDir=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementDir), input_name='elementDir')), ))
        if self.elementId is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            outfile.write(' elementId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementId), input_name='elementId')), ))
        if self.elementS is not None and 'elementS' not in already_processed:
            already_processed.add('elementS')
            outfile.write(' elementS="%s"' % self.gds_format_double(self.elementS, input_name='elementS'))
        if self.elementType is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            outfile.write(' elementType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.elementType), input_name='elementType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_link_predecessorSuccessor', fromsubclass_=False, pretty_print=True):
        super(t_road_link_predecessorSuccessor, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('contactPoint', node)
        if value is not None and 'contactPoint' not in already_processed:
            already_processed.add('contactPoint')
            self.contactPoint = value
            self.validate_e_contactPoint(self.contactPoint)    # validate type e_contactPoint
        value = find_attr_value_('elementDir', node)
        if value is not None and 'elementDir' not in already_processed:
            already_processed.add('elementDir')
            self.elementDir = value
            self.validate_e_elementDir(self.elementDir)    # validate type e_elementDir
        value = find_attr_value_('elementId', node)
        if value is not None and 'elementId' not in already_processed:
            already_processed.add('elementId')
            self.elementId = value
        value = find_attr_value_('elementS', node)
        if value is not None and 'elementS' not in already_processed:
            already_processed.add('elementS')
            value = self.gds_parse_double(value, node, 'elementS')
            self.elementS = value
            self.validate_t_grEqZero(self.elementS)    # validate type t_grEqZero
        value = find_attr_value_('elementType', node)
        if value is not None and 'elementType' not in already_processed:
            already_processed.add('elementType')
            self.elementType = value
            self.validate_e_road_link_elementType(self.elementType)    # validate type e_road_link_elementType
        super(t_road_link_predecessorSuccessor, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_link_predecessorSuccessor, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_link_predecessorSuccessor


class t_road_planView(_OpenDriveElement):
    """t_road_planView -- Contains geometry elements that define the layout of the road reference line in the x/y-plane (plan view).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, geometry=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_planView"), self).__init__( **kwargs_)
        if geometry is None:
            self.geometry = []
        else:
            self.geometry = geometry
        self.geometry_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView.subclass:
            return t_road_planView.subclass(*args_, **kwargs_)
        else:
            return t_road_planView(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.geometry or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_planView, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_planView':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView'):
        super(t_road_planView, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView', fromsubclass_=False, pretty_print=True):
        super(t_road_planView, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for geometry_ in self.geometry:
            namespaceprefix_ = self.geometry_nsprefix_ + ':' if (UseCapturedNS_ and self.geometry_nsprefix_) else ''
            geometry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geometry', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_planView, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'geometry':
            obj_ = t_road_planView_geometry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geometry.append(obj_)
            obj_.original_tagname_ = 'geometry'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_planView, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_planView


class t_road_planView_geometry(_OpenDriveElement):
    """hdg -- Start orientation (inertial heading)
    length -- Length of the element's reference line
    s -- s-coordinate of start position
    x -- Start position (x inertial)
    y -- Start position (y inertial)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, hdg=None, length=None, s=None, x=None, y=None, line=None, spiral=None, arc=None, poly3=None, paramPoly3=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_planView_geometry"), self).__init__( **kwargs_)
        self.hdg = _cast(float, hdg)
        self.hdg_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.line = line
        self.line_nsprefix_ = None
        self.spiral = spiral
        self.spiral_nsprefix_ = None
        self.arc = arc
        self.arc_nsprefix_ = None
        self.poly3 = poly3
        self.poly3_nsprefix_ = None
        self.paramPoly3 = paramPoly3
        self.paramPoly3_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry.subclass:
            return t_road_planView_geometry.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grZero(self, value):
        # Validate type t_grZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on t_grZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.line is not None or
            self.spiral is not None or
            self.arc is not None or
            self.poly3 is not None or
            self.paramPoly3 is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_planView_geometry, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_planView_geometry':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry'):
        super(t_road_planView_geometry, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry')
        if self.hdg is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            outfile.write(' hdg="%s"' % self.gds_format_double(self.hdg, input_name='hdg'))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry', fromsubclass_=False, pretty_print=True):
        super(t_road_planView_geometry, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.line is not None:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            self.line.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line', pretty_print=pretty_print)
        if self.spiral is not None:
            namespaceprefix_ = self.spiral_nsprefix_ + ':' if (UseCapturedNS_ and self.spiral_nsprefix_) else ''
            self.spiral.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spiral', pretty_print=pretty_print)
        if self.arc is not None:
            namespaceprefix_ = self.arc_nsprefix_ + ':' if (UseCapturedNS_ and self.arc_nsprefix_) else ''
            self.arc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arc', pretty_print=pretty_print)
        if self.poly3 is not None:
            namespaceprefix_ = self.poly3_nsprefix_ + ':' if (UseCapturedNS_ and self.poly3_nsprefix_) else ''
            self.poly3.export(outfile, level, namespaceprefix_, namespacedef_='', name_='poly3', pretty_print=pretty_print)
        if self.paramPoly3 is not None:
            namespaceprefix_ = self.paramPoly3_nsprefix_ + ':' if (UseCapturedNS_ and self.paramPoly3_nsprefix_) else ''
            self.paramPoly3.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paramPoly3', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hdg', node)
        if value is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            value = self.gds_parse_double(value, node, 'hdg')
            self.hdg = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
            self.validate_t_grZero(self.length)    # validate type t_grZero
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            value = self.gds_parse_double(value, node, 'x')
            self.x = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            value = self.gds_parse_double(value, node, 'y')
            self.y = value
        super(t_road_planView_geometry, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'line':
            obj_ = t_road_planView_geometry_line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.line = obj_
            obj_.original_tagname_ = 'line'
        elif nodeName_ == 'spiral':
            obj_ = t_road_planView_geometry_spiral.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spiral = obj_
            obj_.original_tagname_ = 'spiral'
        elif nodeName_ == 'arc':
            obj_ = t_road_planView_geometry_arc.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arc = obj_
            obj_.original_tagname_ = 'arc'
        elif nodeName_ == 'poly3':
            obj_ = t_road_planView_geometry_poly3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.poly3 = obj_
            obj_.original_tagname_ = 'poly3'
        elif nodeName_ == 'paramPoly3':
            obj_ = t_road_planView_geometry_paramPoly3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.paramPoly3 = obj_
            obj_.original_tagname_ = 'paramPoly3'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_planView_geometry, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_planView_geometry


class t_road_planView_geometry_arc(_OpenDriveElement):
    """t_road_planView_geometry_arc -- An arc describes a road reference line with constant curvature. In ASAM OpenDRIVE, an arc is represented by an
    <
    arc
    >
    element within the
    <
    geometry
    >
    element.
    curvature -- Constant curvature throughout the element
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, curvature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_planView_geometry_arc"), self).__init__( **kwargs_)
        self.curvature = _cast(float, curvature)
        self.curvature_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry_arc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry_arc.subclass:
            return t_road_planView_geometry_arc.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry_arc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_planView_geometry_arc, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_arc', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry_arc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_planView_geometry_arc':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_arc')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry_arc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry_arc'):
        super(t_road_planView_geometry_arc, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_arc')
        if self.curvature is not None and 'curvature' not in already_processed:
            already_processed.add('curvature')
            outfile.write(' curvature="%s"' % self.gds_format_double(self.curvature, input_name='curvature'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_arc', fromsubclass_=False, pretty_print=True):
        super(t_road_planView_geometry_arc, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('curvature', node)
        if value is not None and 'curvature' not in already_processed:
            already_processed.add('curvature')
            value = self.gds_parse_double(value, node, 'curvature')
            self.curvature = value
        super(t_road_planView_geometry_arc, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_planView_geometry_arc, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_planView_geometry_arc


class t_road_planView_geometry_line(_OpenDriveElement):
    """t_road_planView_geometry_line -- A straight line is the simplest geometry element. It contains no further attributes.
    In ASAM OpenDRIVE, a straight line is represented by a
    <
    line
    >
    element within the
    <
    geometry
    >
    element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_planView_geometry_line"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry_line)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry_line.subclass:
            return t_road_planView_geometry_line.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry_line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_planView_geometry_line, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_line', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry_line')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_planView_geometry_line':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_line')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry_line', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry_line'):
        super(t_road_planView_geometry_line, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_line')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_line', fromsubclass_=False, pretty_print=True):
        super(t_road_planView_geometry_line, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_planView_geometry_line, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_planView_geometry_line, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_planView_geometry_line


class t_road_planView_geometry_paramPoly3(_OpenDriveElement):
    """t_road_planView_geometry_paramPoly3 -- In ASAM OpenDRIVE, parametric cubic curves are represented by
    <
    paramPoly3
    >
    elements within the
    <
    geometry
    >
    element.
    aU -- Polynom parameter a for u
    aV -- Polynom parameter a for v
    bU -- Polynom parameter b for u
    bV -- Polynom parameter b for v
    cU -- Polynom parameter c for u
    cV -- Polynom parameter c for v
    dU -- Polynom parameter d for u
    dV -- Polynom parameter d for v
    pRange -- Range of parameter p.
    - Case arcLength: p in [0, @length of
    <
    geometry
    >
    ]
    - Case normalized: p in [0, 1]
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, aU=None, aV=None, bU=None, bV=None, cU=None, cV=None, dU=None, dV=None, pRange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_planView_geometry_paramPoly3"), self).__init__( **kwargs_)
        self.aU = _cast(float, aU)
        self.aU_nsprefix_ = None
        self.aV = _cast(float, aV)
        self.aV_nsprefix_ = None
        self.bU = _cast(float, bU)
        self.bU_nsprefix_ = None
        self.bV = _cast(float, bV)
        self.bV_nsprefix_ = None
        self.cU = _cast(float, cU)
        self.cU_nsprefix_ = None
        self.cV = _cast(float, cV)
        self.cV_nsprefix_ = None
        self.dU = _cast(float, dU)
        self.dU_nsprefix_ = None
        self.dV = _cast(float, dV)
        self.dV_nsprefix_ = None
        self.pRange = _cast(None, pRange)
        self.pRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry_paramPoly3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry_paramPoly3.subclass:
            return t_road_planView_geometry_paramPoly3.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry_paramPoly3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_paramPoly3_pRange(self, value):
        # Validate type e_paramPoly3_pRange, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['arcLength', 'normalized']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_paramPoly3_pRange' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_planView_geometry_paramPoly3, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_paramPoly3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry_paramPoly3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_planView_geometry_paramPoly3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_paramPoly3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry_paramPoly3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry_paramPoly3'):
        super(t_road_planView_geometry_paramPoly3, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_paramPoly3')
        if self.aU is not None and 'aU' not in already_processed:
            already_processed.add('aU')
            outfile.write(' aU="%s"' % self.gds_format_double(self.aU, input_name='aU'))
        if self.aV is not None and 'aV' not in already_processed:
            already_processed.add('aV')
            outfile.write(' aV="%s"' % self.gds_format_double(self.aV, input_name='aV'))
        if self.bU is not None and 'bU' not in already_processed:
            already_processed.add('bU')
            outfile.write(' bU="%s"' % self.gds_format_double(self.bU, input_name='bU'))
        if self.bV is not None and 'bV' not in already_processed:
            already_processed.add('bV')
            outfile.write(' bV="%s"' % self.gds_format_double(self.bV, input_name='bV'))
        if self.cU is not None and 'cU' not in already_processed:
            already_processed.add('cU')
            outfile.write(' cU="%s"' % self.gds_format_double(self.cU, input_name='cU'))
        if self.cV is not None and 'cV' not in already_processed:
            already_processed.add('cV')
            outfile.write(' cV="%s"' % self.gds_format_double(self.cV, input_name='cV'))
        if self.dU is not None and 'dU' not in already_processed:
            already_processed.add('dU')
            outfile.write(' dU="%s"' % self.gds_format_double(self.dU, input_name='dU'))
        if self.dV is not None and 'dV' not in already_processed:
            already_processed.add('dV')
            outfile.write(' dV="%s"' % self.gds_format_double(self.dV, input_name='dV'))
        if self.pRange is not None and 'pRange' not in already_processed:
            already_processed.add('pRange')
            outfile.write(' pRange=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pRange), input_name='pRange')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_paramPoly3', fromsubclass_=False, pretty_print=True):
        super(t_road_planView_geometry_paramPoly3, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aU', node)
        if value is not None and 'aU' not in already_processed:
            already_processed.add('aU')
            value = self.gds_parse_double(value, node, 'aU')
            self.aU = value
        value = find_attr_value_('aV', node)
        if value is not None and 'aV' not in already_processed:
            already_processed.add('aV')
            value = self.gds_parse_double(value, node, 'aV')
            self.aV = value
        value = find_attr_value_('bU', node)
        if value is not None and 'bU' not in already_processed:
            already_processed.add('bU')
            value = self.gds_parse_double(value, node, 'bU')
            self.bU = value
        value = find_attr_value_('bV', node)
        if value is not None and 'bV' not in already_processed:
            already_processed.add('bV')
            value = self.gds_parse_double(value, node, 'bV')
            self.bV = value
        value = find_attr_value_('cU', node)
        if value is not None and 'cU' not in already_processed:
            already_processed.add('cU')
            value = self.gds_parse_double(value, node, 'cU')
            self.cU = value
        value = find_attr_value_('cV', node)
        if value is not None and 'cV' not in already_processed:
            already_processed.add('cV')
            value = self.gds_parse_double(value, node, 'cV')
            self.cV = value
        value = find_attr_value_('dU', node)
        if value is not None and 'dU' not in already_processed:
            already_processed.add('dU')
            value = self.gds_parse_double(value, node, 'dU')
            self.dU = value
        value = find_attr_value_('dV', node)
        if value is not None and 'dV' not in already_processed:
            already_processed.add('dV')
            value = self.gds_parse_double(value, node, 'dV')
            self.dV = value
        value = find_attr_value_('pRange', node)
        if value is not None and 'pRange' not in already_processed:
            already_processed.add('pRange')
            self.pRange = value
            self.validate_e_paramPoly3_pRange(self.pRange)    # validate type e_paramPoly3_pRange
        super(t_road_planView_geometry_paramPoly3, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_planView_geometry_paramPoly3, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_planView_geometry_paramPoly3


class t_road_planView_geometry_poly3(_OpenDriveElement):
    """t_road_planView_geometry_poly3 -- In ASAM OpenDRIVE, a cubic polynom is represented by a
    <
    poly3
    >
    element within the
    <
    geometry
    >
    element.
    a -- Polynom parameter a
    b -- Polynom parameter b
    c -- Polynom parameter c
    d -- Polynom parameter d
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, a=None, b=None, c=None, d=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_planView_geometry_poly3"), self).__init__( **kwargs_)
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry_poly3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry_poly3.subclass:
            return t_road_planView_geometry_poly3.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry_poly3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_planView_geometry_poly3, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_poly3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry_poly3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_planView_geometry_poly3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_poly3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry_poly3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry_poly3'):
        super(t_road_planView_geometry_poly3, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_poly3')
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_poly3', fromsubclass_=False, pretty_print=True):
        super(t_road_planView_geometry_poly3, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
        super(t_road_planView_geometry_poly3, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_planView_geometry_poly3, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_planView_geometry_poly3


class t_road_planView_geometry_spiral(_OpenDriveElement):
    """t_road_planView_geometry_spiral -- In ASAM OpenDRIVE, a spiral is represented by a
    <
    spiral
    >
    element within the
    <
    geometry
    >
    element.
    curvEnd -- Curvature at the end of the element
    curvStart -- Curvature at the start of the element
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, curvEnd=None, curvStart=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_planView_geometry_spiral"), self).__init__( **kwargs_)
        self.curvEnd = _cast(float, curvEnd)
        self.curvEnd_nsprefix_ = None
        self.curvStart = _cast(float, curvStart)
        self.curvStart_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_planView_geometry_spiral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_planView_geometry_spiral.subclass:
            return t_road_planView_geometry_spiral.subclass(*args_, **kwargs_)
        else:
            return t_road_planView_geometry_spiral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_planView_geometry_spiral, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_spiral', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_planView_geometry_spiral')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_planView_geometry_spiral':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_spiral')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_planView_geometry_spiral', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_planView_geometry_spiral'):
        super(t_road_planView_geometry_spiral, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_planView_geometry_spiral')
        if self.curvEnd is not None and 'curvEnd' not in already_processed:
            already_processed.add('curvEnd')
            outfile.write(' curvEnd="%s"' % self.gds_format_double(self.curvEnd, input_name='curvEnd'))
        if self.curvStart is not None and 'curvStart' not in already_processed:
            already_processed.add('curvStart')
            outfile.write(' curvStart="%s"' % self.gds_format_double(self.curvStart, input_name='curvStart'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_planView_geometry_spiral', fromsubclass_=False, pretty_print=True):
        super(t_road_planView_geometry_spiral, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('curvEnd', node)
        if value is not None and 'curvEnd' not in already_processed:
            already_processed.add('curvEnd')
            value = self.gds_parse_double(value, node, 'curvEnd')
            self.curvEnd = value
        value = find_attr_value_('curvStart', node)
        if value is not None and 'curvStart' not in already_processed:
            already_processed.add('curvStart')
            value = self.gds_parse_double(value, node, 'curvStart')
            self.curvStart = value
        super(t_road_planView_geometry_spiral, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_planView_geometry_spiral, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_planView_geometry_spiral


class t_road_surface(_OpenDriveElement):
    """t_road_surface -- In ASAM OpenDRIVE, the road surface is represented by the
    <
    surface
    >
    element within the
    <
    road
    >
    element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, CRG=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_surface"), self).__init__( **kwargs_)
        if CRG is None:
            self.CRG = []
        else:
            self.CRG = CRG
        self.CRG_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_surface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_surface.subclass:
            return t_road_surface.subclass(*args_, **kwargs_)
        else:
            return t_road_surface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.CRG or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_surface, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_surface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_surface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_surface':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_surface')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_surface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_surface'):
        super(t_road_surface, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_surface')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_surface', fromsubclass_=False, pretty_print=True):
        super(t_road_surface, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CRG_ in self.CRG:
            namespaceprefix_ = self.CRG_nsprefix_ + ':' if (UseCapturedNS_ and self.CRG_nsprefix_) else ''
            CRG_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CRG', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_surface, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CRG':
            obj_ = t_road_surface_CRG.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CRG.append(obj_)
            obj_.original_tagname_ = 'CRG'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_surface, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_surface


class t_road_surface_CRG(_OpenDriveElement):
    """t_road_surface_CRG -- Data described in OpenCRG is represented by the
    <
    CRG
    >
    element within the
    <
    surface
    >
    element.
    file -- Name of the file containing the CRG data
    hOffset -- Heading offset between CRG center line and reference line of the road (only allowed for mode genuine, default = 0.0).
    mode -- Attachment mode for the surface data, see specification.
    orientation -- Orientation of the CRG data set relative to the parent
    <
    road
    >
    element. Only allowed for mode attached and attached0.
    purpose -- Physical purpose of the data contained in the CRG file; if the attribute is missing, data will be interpreted as elevation data.
    sEnd -- End of the application of CRG
    (s-coordinate)
    sOffset -- s-offset between CRG center line and reference line of the road
    (default = 0.0)
    sStart -- Start of the application of CRG data
    (s-coordinate)
    tOffset -- t-offset between CRG center line and reference line of the road
    (default = 0.0)
    zOffset -- z-offset between CRG center line and reference line of the road (default = 0.0). Only allowed for purpose elevation.
    zScale -- z-scale factor for the surface description (default = 1.0). Only allowed for purpose elevation.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, file=None, hOffset=None, mode=None, orientation=None, purpose=None, sEnd=None, sOffset=None, sStart=None, tOffset=None, zOffset=None, zScale=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_surface_CRG"), self).__init__( **kwargs_)
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
        self.hOffset = _cast(float, hOffset)
        self.hOffset_nsprefix_ = None
        self.mode = _cast(None, mode)
        self.mode_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.purpose = _cast(None, purpose)
        self.purpose_nsprefix_ = None
        self.sEnd = _cast(float, sEnd)
        self.sEnd_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.sStart = _cast(float, sStart)
        self.sStart_nsprefix_ = None
        self.tOffset = _cast(float, tOffset)
        self.tOffset_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        self.zScale = _cast(float, zScale)
        self.zScale_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_surface_CRG)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_surface_CRG.subclass:
            return t_road_surface_CRG.subclass(*args_, **kwargs_)
        else:
            return t_road_surface_CRG(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_road_surface_CRG_mode(self, value):
        # Validate type e_road_surface_CRG_mode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['attached', 'attached0', 'genuine', 'global']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_road_surface_CRG_mode' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_direction(self, value):
        # Validate type e_direction, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['same', 'opposite']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_road_surface_CRG_purpose(self, value):
        # Validate type e_road_surface_CRG_purpose, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['elevation', 'friction']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_road_surface_CRG_purpose' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_surface_CRG, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_surface_CRG', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_surface_CRG')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_surface_CRG':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_surface_CRG')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_surface_CRG', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_surface_CRG'):
        super(t_road_surface_CRG, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_surface_CRG')
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
        if self.hOffset is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            outfile.write(' hOffset="%s"' % self.gds_format_double(self.hOffset, input_name='hOffset'))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mode), input_name='mode')), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if self.purpose is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            outfile.write(' purpose=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.purpose), input_name='purpose')), ))
        if self.sEnd is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            outfile.write(' sEnd="%s"' % self.gds_format_double(self.sEnd, input_name='sEnd'))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.sStart is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            outfile.write(' sStart="%s"' % self.gds_format_double(self.sStart, input_name='sStart'))
        if self.tOffset is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            outfile.write(' tOffset="%s"' % self.gds_format_double(self.tOffset, input_name='tOffset'))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
        if self.zScale is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            outfile.write(' zScale="%s"' % self.gds_format_double(self.zScale, input_name='zScale'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_surface_CRG', fromsubclass_=False, pretty_print=True):
        super(t_road_surface_CRG, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
        value = find_attr_value_('hOffset', node)
        if value is not None and 'hOffset' not in already_processed:
            already_processed.add('hOffset')
            value = self.gds_parse_double(value, node, 'hOffset')
            self.hOffset = value
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
            self.validate_e_road_surface_CRG_mode(self.mode)    # validate type e_road_surface_CRG_mode
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_e_direction(self.orientation)    # validate type e_direction
        value = find_attr_value_('purpose', node)
        if value is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            self.purpose = value
            self.validate_e_road_surface_CRG_purpose(self.purpose)    # validate type e_road_surface_CRG_purpose
        value = find_attr_value_('sEnd', node)
        if value is not None and 'sEnd' not in already_processed:
            already_processed.add('sEnd')
            value = self.gds_parse_double(value, node, 'sEnd')
            self.sEnd = value
            self.validate_t_grEqZero(self.sEnd)    # validate type t_grEqZero
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
        value = find_attr_value_('sStart', node)
        if value is not None and 'sStart' not in already_processed:
            already_processed.add('sStart')
            value = self.gds_parse_double(value, node, 'sStart')
            self.sStart = value
            self.validate_t_grEqZero(self.sStart)    # validate type t_grEqZero
        value = find_attr_value_('tOffset', node)
        if value is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            value = self.gds_parse_double(value, node, 'tOffset')
            self.tOffset = value
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            value = self.gds_parse_double(value, node, 'zOffset')
            self.zOffset = value
        value = find_attr_value_('zScale', node)
        if value is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            value = self.gds_parse_double(value, node, 'zScale')
            self.zScale = value
        super(t_road_surface_CRG, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_surface_CRG, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_surface_CRG


class t_road_type(_OpenDriveElement):
    """t_road_type -- A road type element is valid for the entire cross section of a road. It is valid until a new road type element is provided or until the road ends.
    country -- Country code of the road, see ISO 3166-1, alpha-2 codes.
    s -- s-coordinate of start position
    type -- Type of the road defined as enumeration
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, country=None, s=None, type_=None, speed=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_type"), self).__init__( **kwargs_)
        self.country = _cast(None, country)
        self.country_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.speed = speed
        self.speed_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_type.subclass:
            return t_road_type.subclass(*args_, **kwargs_)
        else:
            return t_road_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_countryCode(self, value):
        # Validate type e_countryCode, a restriction on None.
        pass
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_roadType(self, value):
        # Validate type e_roadType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['unknown', 'rural', 'motorway', 'town', 'lowSpeed', 'pedestrian', 'bicycle', 'townExpressway', 'townCollector', 'townArterial', 'townPrivate', 'townLocal', 'townPlayStreet']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_roadType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.speed is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_type, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_type')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_type'):
        super(t_road_type, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_type')
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            outfile.write(' country=%s' % (quote_attrib(self.country), ))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_type', fromsubclass_=False, pretty_print=True):
        super(t_road_type, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.speed is not None:
            namespaceprefix_ = self.speed_nsprefix_ + ':' if (UseCapturedNS_ and self.speed_nsprefix_) else ''
            self.speed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='speed', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('country', node)
        if value is not None and 'country' not in already_processed:
            already_processed.add('country')
            self.country = value
            self.validate_e_countryCode(self.country)    # validate type e_countryCode
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_roadType(self.type_)    # validate type e_roadType
        super(t_road_type, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'speed':
            obj_ = t_road_type_speed.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.speed = obj_
            obj_.original_tagname_ = 'speed'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_type, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_type


class t_road_type_speed(_OpenDriveElement):
    """t_road_type_speed -- Defines the default maximum speed allowed in conjunction with the specified road type.
    max -- Maximum allowed speed. Given as string (only "no limit" / "undefined") or numerical value in the respective unit (see attribute unit). If the attribute unit is not specified, m/s is used as default.
    unit -- Unit of the attribute max. For values, see chapter
    “
    units
    ”
    .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, max=None, unit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_type_speed"), self).__init__( **kwargs_)
        self.max = _cast(None, max)
        self.max_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_type_speed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_type_speed.subclass:
            return t_road_type_speed.subclass(*args_, **kwargs_)
        else:
            return t_road_type_speed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_maxSpeed(self, value):
        # Validate type t_maxSpeed, a restriction on None.
        pass
    def validate_e_unitSpeed(self, value):
        # Validate type e_unitSpeed, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['m/s', 'mph', 'km/h']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_unitSpeed' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_type_speed, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_type_speed', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_type_speed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_type_speed':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_type_speed')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_type_speed', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_type_speed'):
        super(t_road_type_speed, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_type_speed')
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max=%s' % (quote_attrib(self.max), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_type_speed', fromsubclass_=False, pretty_print=True):
        super(t_road_type_speed, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            self.max = value
            self.validate_t_maxSpeed(self.max)    # validate type t_maxSpeed
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_e_unitSpeed(self.unit)    # validate type e_unitSpeed
        super(t_road_type_speed, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_type_speed, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_type_speed


class t_road_lanes(_OpenDriveElement):
    """t_road_lanes -- Contains a series of lane section elements that define the characteristics of the road cross sections with respect to the lanes along the reference line.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, laneOffset=None, laneSection=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes"), self).__init__( **kwargs_)
        if laneOffset is None:
            self.laneOffset = []
        else:
            self.laneOffset = laneOffset
        self.laneOffset_nsprefix_ = None
        if laneSection is None:
            self.laneSection = []
        else:
            self.laneSection = laneSection
        self.laneSection_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes.subclass:
            return t_road_lanes.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.laneOffset or
            self.laneSection or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_lanes, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes'):
        super(t_road_lanes, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for laneOffset_ in self.laneOffset:
            namespaceprefix_ = self.laneOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.laneOffset_nsprefix_) else ''
            laneOffset_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='laneOffset', pretty_print=pretty_print)
        for laneSection_ in self.laneSection:
            namespaceprefix_ = self.laneSection_nsprefix_ + ':' if (UseCapturedNS_ and self.laneSection_nsprefix_) else ''
            laneSection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='laneSection', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_lanes, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'laneOffset':
            obj_ = t_road_lanes_laneOffset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.laneOffset.append(obj_)
            obj_.original_tagname_ = 'laneOffset'
        elif nodeName_ == 'laneSection':
            obj_ = t_road_lanes_laneSection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.laneSection.append(obj_)
            obj_.original_tagname_ = 'laneSection'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_lanes, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_lanes


class t_road_lanes_laneOffset(_OpenDriveElement):
    """t_road_lanes_laneOffset -- A lane offset may be used to shift the center lane away from the road reference line.
    a -- Polynom parameter a, offset at @s (ds=0)
    b -- Polynom parameter b
    c -- Polynom parameter c
    d -- Polynom parameter d
    s -- s-coordinate of start position
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, a=None, b=None, c=None, d=None, s=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneOffset"), self).__init__( **kwargs_)
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneOffset.subclass:
            return t_road_lanes_laneOffset.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lanes_laneOffset, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneOffset', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneOffset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneOffset':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneOffset')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneOffset', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneOffset'):
        super(t_road_lanes_laneOffset, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneOffset')
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneOffset', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneOffset, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        super(t_road_lanes_laneOffset, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneOffset, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneOffset


class t_road_lanes_laneSection(_OpenDriveElement):
    """t_road_lanes_laneSection -- Lanes may be split into multiple lane sections. Each lane section contains a fixed number of lanes. Every time the number of lanes changes, a new lane section is required. The distance between two succeeding lane sections shall not be zero.
    s -- s-coordinate of start position
    singleSide -- Lane section element is valid for one side only (left, center, or right), depending on the child elements.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, s=None, singleSide=None, left=None, center=None, right=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection"), self).__init__( **kwargs_)
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.singleSide = _cast(None, singleSide)
        self.singleSide_nsprefix_ = None
        self.left = left
        self.left_nsprefix_ = None
        self.center = center
        self.center_nsprefix_ = None
        self.right = right
        self.right_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection.subclass:
            return t_road_lanes_laneSection.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_t_bool(self, value):
        # Validate type t_bool, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['true', 'false']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on t_bool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.left is not None or
            self.center is not None or
            self.right is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_lanes_laneSection, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection'):
        super(t_road_lanes_laneSection, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection')
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.singleSide is not None and 'singleSide' not in already_processed:
            already_processed.add('singleSide')
            outfile.write(' singleSide=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.singleSide), input_name='singleSide')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left is not None:
            namespaceprefix_ = self.left_nsprefix_ + ':' if (UseCapturedNS_ and self.left_nsprefix_) else ''
            self.left.export(outfile, level, namespaceprefix_, namespacedef_='', name_='left', pretty_print=pretty_print)
        if self.center is not None:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            self.center.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        if self.right is not None:
            namespaceprefix_ = self.right_nsprefix_ + ':' if (UseCapturedNS_ and self.right_nsprefix_) else ''
            self.right.export(outfile, level, namespaceprefix_, namespacedef_='', name_='right', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('singleSide', node)
        if value is not None and 'singleSide' not in already_processed:
            already_processed.add('singleSide')
            self.singleSide = value
            self.validate_t_bool(self.singleSide)    # validate type t_bool
        super(t_road_lanes_laneSection, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'left':
            obj_ = t_road_lanes_laneSection_left.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.left = obj_
            obj_.original_tagname_ = 'left'
        elif nodeName_ == 'center':
            obj_ = t_road_lanes_laneSection_center.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.center = obj_
            obj_.original_tagname_ = 'center'
        elif nodeName_ == 'right':
            obj_ = t_road_lanes_laneSection_right.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.right = obj_
            obj_.original_tagname_ = 'right'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_lanes_laneSection, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_lanes_laneSection


class t_road_lanes_laneSection_center(_OpenDriveElement):
    """t_road_lanes_laneSection_center -- For easier navigation through an ASAM OpenDRIVE road description, the lanes within a lane section are grouped into left, center, and right lanes. Each lane section shall contain one
    <
    center
    >
    element and at least one
    <
    right
    >
    or
    <
    left
    >
    element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, lane=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_center"), self).__init__( **kwargs_)
        if lane is None:
            self.lane = []
        else:
            self.lane = lane
        self.lane_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_center)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_center.subclass:
            return t_road_lanes_laneSection_center.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_center(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.lane or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_lanes_laneSection_center, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_center', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_center')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_center':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_center')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_center', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_center'):
        super(t_road_lanes_laneSection_center, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_center')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_center', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_center, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for lane_ in self.lane:
            namespaceprefix_ = self.lane_nsprefix_ + ':' if (UseCapturedNS_ and self.lane_nsprefix_) else ''
            lane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lane', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_lanes_laneSection_center, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lane':
            obj_ = t_road_lanes_laneSection_center_lane.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lane.append(obj_)
            obj_.original_tagname_ = 'lane'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_lanes_laneSection_center, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_lanes_laneSection_center


class t_road_lanes_laneSection_lcr_lane_link(_OpenDriveElement):
    """t_road_lanes_laneSection_lcr_lane_link -- For links between lanes with an identical reference line, the lane predecessor and successor information provide the IDs of lanes on the preceding or following lane section.
    For links between lanes with different reference line,  the lane predecessor and successor information provide the IDs of lanes on the first or last lane section of the other reference line depending on the contact point of the road linkage.
    This element may only be omitted, if lanes end at a junction or have no physical link.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, predecessor=None, successor=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lcr_lane_link"), self).__init__( **kwargs_)
        if predecessor is None:
            self.predecessor = []
        else:
            self.predecessor = predecessor
        self.predecessor_nsprefix_ = None
        if successor is None:
            self.successor = []
        else:
            self.successor = successor
        self.successor_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_link)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_link.subclass:
            return t_road_lanes_laneSection_lcr_lane_link.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.predecessor or
            self.successor or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_lanes_laneSection_lcr_lane_link, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_link', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_link')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lcr_lane_link':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_link')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_link', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_link'):
        super(t_road_lanes_laneSection_lcr_lane_link, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_link')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_link', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lcr_lane_link, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for predecessor_ in self.predecessor:
            namespaceprefix_ = self.predecessor_nsprefix_ + ':' if (UseCapturedNS_ and self.predecessor_nsprefix_) else ''
            predecessor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='predecessor', pretty_print=pretty_print)
        for successor_ in self.successor:
            namespaceprefix_ = self.successor_nsprefix_ + ':' if (UseCapturedNS_ and self.successor_nsprefix_) else ''
            successor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='successor', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_lanes_laneSection_lcr_lane_link, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'predecessor':
            obj_ = t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.predecessor.append(obj_)
            obj_.original_tagname_ = 'predecessor'
        elif nodeName_ == 'successor':
            obj_ = t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.successor.append(obj_)
            obj_.original_tagname_ = 'successor'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_lanes_laneSection_lcr_lane_link, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_lanes_laneSection_lcr_lane_link


class t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor(_OpenDriveElement):
    """id -- ID of the preceding / succeeding linked lane
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor"), self).__init__( **kwargs_)
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor.subclass:
            return t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor'):
        super(t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
        super(t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor


class t_road_lanes_laneSection_lcr_lane_roadMark(_OpenDriveElement):
    """t_road_lanes_laneSection_lcr_lane_roadMark -- Defines the style of the line at the outer border of a lane. The style of the center line that separates left and right lanes is determined by the road mark element for the center lane.
    color -- Color of the road mark
    height -- Height of road mark above the road, i.e. thickness of the road mark
    laneChange -- Allows a lane change in the indicated direction, taking into account that lanes are numbered in ascending order from right to left. If the attribute is missing,
    “
    both
    ”
    is used as default.
    material -- Material of the road mark. Identifiers to be defined by the user, use "standard" as default value.
    sOffset -- s-coordinate of start position of the
    <
    roadMark
    >
    element, relative to the position of the preceding
    <
    laneSection
    >
    element
    type -- Type of the road mark
    weight -- Weight of the road mark. This attribute is optional if detailed definition is given below.
    width -- Width of the road mark. This attribute is optional if detailed definition is given by
    <
    line
    >
    element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, color=None, height=None, laneChange=None, material=None, sOffset=None, type__attr=None, weight=None, width=None, sway=None, type_=None, explicit=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lcr_lane_roadMark"), self).__init__( **kwargs_)
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.laneChange = _cast(None, laneChange)
        self.laneChange_nsprefix_ = None
        self.material = _cast(None, material)
        self.material_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.type__attr = _cast(None, type__attr)
        self.type__attr_nsprefix_ = None
        self.weight = _cast(None, weight)
        self.weight_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        if sway is None:
            self.sway = []
        else:
            self.sway = sway
        self.sway_nsprefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
        self.explicit = explicit
        self.explicit_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_roadMarkColor(self, value):
        # Validate type e_roadMarkColor, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'blue', 'green', 'red', 'white', 'yellow', 'orange', 'violet']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_roadMarkColor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grZero(self, value):
        # Validate type t_grZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on t_grZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange(self, value):
        # Validate type e_road_lanes_laneSection_lcr_lane_roadMark_laneChange, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['increase', 'decrease', 'both', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_road_lanes_laneSection_lcr_lane_roadMark_laneChange' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_roadMarkType(self, value):
        # Validate type e_roadMarkType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'solid', 'broken', 'solid solid', 'solid broken', 'broken solid', 'broken broken', 'botts dots', 'grass', 'curb', 'custom', 'edge']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_roadMarkType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_roadMarkWeight(self, value):
        # Validate type e_roadMarkWeight, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_roadMarkWeight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.sway or
            self.type_ is not None or
            self.explicit is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_lanes_laneSection_lcr_lane_roadMark, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lcr_lane_roadMark':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark'):
        super(t_road_lanes_laneSection_lcr_lane_roadMark, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark')
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.laneChange is not None and 'laneChange' not in already_processed:
            already_processed.add('laneChange')
            outfile.write(' laneChange=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.laneChange), input_name='laneChange')), ))
        if self.material is not None and 'material' not in already_processed:
            already_processed.add('material')
            outfile.write(' material=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.material), input_name='material')), ))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.type__attr is not None and 'type__attr' not in already_processed:
            already_processed.add('type__attr')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type__attr), input_name='type__attr')), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.weight), input_name='weight')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lcr_lane_roadMark, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sway_ in self.sway:
            namespaceprefix_ = self.sway_nsprefix_ + ':' if (UseCapturedNS_ and self.sway_nsprefix_) else ''
            sway_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sway', pretty_print=pretty_print)
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            self.type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        if self.explicit is not None:
            namespaceprefix_ = self.explicit_nsprefix_ + ':' if (UseCapturedNS_ and self.explicit_nsprefix_) else ''
            self.explicit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='explicit', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.validate_e_roadMarkColor(self.color)    # validate type e_roadMarkColor
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_double(value, node, 'height')
            self.height = value
            self.validate_t_grZero(self.height)    # validate type t_grZero
        value = find_attr_value_('laneChange', node)
        if value is not None and 'laneChange' not in already_processed:
            already_processed.add('laneChange')
            self.laneChange = value
            self.validate_e_road_lanes_laneSection_lcr_lane_roadMark_laneChange(self.laneChange)    # validate type e_road_lanes_laneSection_lcr_lane_roadMark_laneChange
        value = find_attr_value_('material', node)
        if value is not None and 'material' not in already_processed:
            already_processed.add('material')
            self.material = value
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('type', node)
        if value is not None and 'type__attr' not in already_processed:
            already_processed.add('type__attr')
            self.type__attr = value
            self.validate_e_roadMarkType(self.type__attr)    # validate type e_roadMarkType
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            self.weight = value
            self.validate_e_roadMarkWeight(self.weight)    # validate type e_roadMarkWeight
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
            self.validate_t_grEqZero(self.width)    # validate type t_grEqZero
        super(t_road_lanes_laneSection_lcr_lane_roadMark, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sway':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark_sway.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sway.append(obj_)
            obj_.original_tagname_ = 'sway'
        elif nodeName_ == 'type':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark_type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'explicit':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark_explicit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.explicit = obj_
            obj_.original_tagname_ = 'explicit'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_lanes_laneSection_lcr_lane_roadMark, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_lanes_laneSection_lcr_lane_roadMark


class t_road_lanes_laneSection_lcr_lane_roadMark_explicit(_OpenDriveElement):
    """t_road_lanes_laneSection_lcr_lane_roadMark_explicit -- Irregular road markings that cannot be described by repetitive line patterns may be described by individual road marking elements. These explicit definitions also contain
    <
    line
    >
    elements for the line definition, however, these lines will not be repeated automatically as in repetitive road marking types. In ASAM OpenDRIVE, irregular road marking types and lines are represented by
    <
    explicit
    >
    elements within elements. The line definitions are contained in
    <
    line
    >
    elements within the
    <
    explicit
    >
    element.
    The
    <
    explicit
    >
    element should specifically be used for measurement data.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, line=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lcr_lane_roadMark_explicit"), self).__init__( **kwargs_)
        if line is None:
            self.line = []
        else:
            self.line = line
        self.line_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark_explicit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark_explicit.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark_explicit.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark_explicit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.line or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_lanes_laneSection_lcr_lane_roadMark_explicit, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark_explicit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lcr_lane_roadMark_explicit':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit'):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_explicit, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_explicit, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for line_ in self.line:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            line_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_explicit, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'line':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.line.append(obj_)
            obj_.original_tagname_ = 'line'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_lanes_laneSection_lcr_lane_roadMark_explicit, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_lanes_laneSection_lcr_lane_roadMark_explicit


class t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line(_OpenDriveElement):
    """t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line -- Specifies a single line in an explicit road mark definition.
    length -- Length of the visible line
    rule -- Rule that must be observed when passing the line from inside, that is, from the lane with the lower absolute ID to the lane with the higher absolute ID
    sOffset -- Offset of start position of the
    <
    line
    >
    element, relative to the @sOffset  given in the
    <
    roadMark
    >
    element
    tOffset -- Lateral offset from the lane border.
    If
    <
    sway
    >
    element is present, the lateral offset follows the sway.
    width -- Line width. This attribute supersedes the definition in the
    <
    roadMark
    >
    element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, length=None, rule=None, sOffset=None, tOffset=None, width=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line"), self).__init__( **kwargs_)
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.rule = _cast(None, rule)
        self.rule_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.tOffset = _cast(float, tOffset)
        self.tOffset_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grZero(self, value):
        # Validate type t_grZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on t_grZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_roadMarkRule(self, value):
        # Validate type e_roadMarkRule, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['no passing', 'caution', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_roadMarkRule' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lcr_lane_roadMark_explicit_line':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line'):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line')
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.rule is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            outfile.write(' rule=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rule), input_name='rule')), ))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.tOffset is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            outfile.write(' tOffset="%s"' % self.gds_format_double(self.tOffset, input_name='tOffset'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
            self.validate_t_grZero(self.length)    # validate type t_grZero
        value = find_attr_value_('rule', node)
        if value is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            self.rule = value
            self.validate_e_roadMarkRule(self.rule)    # validate type e_roadMarkRule
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('tOffset', node)
        if value is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            value = self.gds_parse_double(value, node, 'tOffset')
            self.tOffset = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
            self.validate_t_grZero(self.width)    # validate type t_grZero
        super(t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line


class t_road_lanes_laneSection_lcr_lane_roadMark_sway(_OpenDriveElement):
    """t_road_lanes_laneSection_lcr_lane_roadMark_sway -- Relocates the lateral reference position for the following (explicit) type definition and thus defines an offset. The sway offset is relative to the nominal reference position of the lane marking, meaning the lane border.
    a -- Polynom parameter a, sway value at @s (ds=0)
    b -- Polynom parameter b
    c -- Polynom parameter c
    d -- Polynom parameter d
    ds -- s-coordinate of start position of the
    <
    sway
    >
    element, relative to the @sOffset given in the
    <
    roadMark
    >
    element
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, a=None, b=None, c=None, d=None, ds=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lcr_lane_roadMark_sway"), self).__init__( **kwargs_)
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        self.ds = _cast(float, ds)
        self.ds_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark_sway)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark_sway.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark_sway.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark_sway(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_lcr_lane_roadMark_sway, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_sway', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark_sway')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lcr_lane_roadMark_sway':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_sway')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_sway', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_sway'):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_sway, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_sway')
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
        if self.ds is not None and 'ds' not in already_processed:
            already_processed.add('ds')
            outfile.write(' ds="%s"' % self.gds_format_double(self.ds, input_name='ds'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_sway', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_sway, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
        value = find_attr_value_('ds', node)
        if value is not None and 'ds' not in already_processed:
            already_processed.add('ds')
            value = self.gds_parse_double(value, node, 'ds')
            self.ds = value
            self.validate_t_grEqZero(self.ds)    # validate type t_grEqZero
        super(t_road_lanes_laneSection_lcr_lane_roadMark_sway, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_sway, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_lcr_lane_roadMark_sway


class t_road_lanes_laneSection_lcr_lane_roadMark_type(_OpenDriveElement):
    """t_road_lanes_laneSection_lcr_lane_roadMark_type -- Each type definition shall contain one or more line definitions with additional information about the lines that the road mark is composed of.
    name -- Name of the road mark type. May be chosen freely.
    width -- Accumulated width of the road mark. In case of several
    <
    line
    >
    elements this @width is the sum of all @width of
    <
    line
    >
    elements and spaces in between, necessary to form the road mark. This attribute supersedes the definition in the
    <
    roadMark
    >
    element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, name=None, width=None, line=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lcr_lane_roadMark_type"), self).__init__( **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        if line is None:
            self.line = []
        else:
            self.line = line
        self.line_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark_type.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark_type.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grZero(self, value):
        # Validate type t_grZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on t_grZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.line or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_lanes_laneSection_lcr_lane_roadMark_type, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lcr_lane_roadMark_type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_type')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type'):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_type, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_type')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_type, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for line_ in self.line:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            line_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
            self.validate_t_grZero(self.width)    # validate type t_grZero
        super(t_road_lanes_laneSection_lcr_lane_roadMark_type, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'line':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark_type_line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.line.append(obj_)
            obj_.original_tagname_ = 'line'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_lanes_laneSection_lcr_lane_roadMark_type, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_lanes_laneSection_lcr_lane_roadMark_type


class t_road_lanes_laneSection_lcr_lane_roadMark_type_line(_OpenDriveElement):
    """t_road_lanes_laneSection_lcr_lane_roadMark_type_line -- A road mark may consist of one or more elements. Multiple elements are usually positioned side-by-side. A line definition is valid for a given length of the lane and will be repeated automatically.
    color -- Line color. If given, this attribute supersedes the definition in the
    <
    roadMark
    >
    element.
    length -- Length of the visible part
    rule -- Rule that must be observed when passing the line from inside, for example, from the lane with the lower absolute ID to the lane with the higher absolute ID
    sOffset -- Initial longitudinal offset of the line definition from the start of the road mark definition
    space -- Length of the gap between the visible parts
    tOffset -- Lateral offset from the lane border.
    If
    <
    sway
    >
    element is present, the lateral offset follows the sway.
    width -- Line width
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, color=None, length=None, rule=None, sOffset=None, space=None, tOffset=None, width=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lcr_lane_roadMark_type_line"), self).__init__( **kwargs_)
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.rule = _cast(None, rule)
        self.rule_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.space = _cast(float, space)
        self.space_nsprefix_ = None
        self.tOffset = _cast(float, tOffset)
        self.tOffset_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lcr_lane_roadMark_type_line)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lcr_lane_roadMark_type_line.subclass:
            return t_road_lanes_laneSection_lcr_lane_roadMark_type_line.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lcr_lane_roadMark_type_line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_roadMarkColor(self, value):
        # Validate type e_roadMarkColor, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'blue', 'green', 'red', 'white', 'yellow', 'orange', 'violet']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_roadMarkColor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_roadMarkRule(self, value):
        # Validate type e_roadMarkRule, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['no passing', 'caution', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_roadMarkRule' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grZero(self, value):
        # Validate type t_grZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on t_grZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_lcr_lane_roadMark_type_line, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type_line', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lcr_lane_roadMark_type_line')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lcr_lane_roadMark_type_line':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_type_line')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_type_line', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type_line'):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_type_line, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lcr_lane_roadMark_type_line')
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.rule is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            outfile.write(' rule=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rule), input_name='rule')), ))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space="%s"' % self.gds_format_double(self.space, input_name='space'))
        if self.tOffset is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            outfile.write(' tOffset="%s"' % self.gds_format_double(self.tOffset, input_name='tOffset'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lcr_lane_roadMark_type_line', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_type_line, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.validate_e_roadMarkColor(self.color)    # validate type e_roadMarkColor
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
            self.validate_t_grEqZero(self.length)    # validate type t_grEqZero
        value = find_attr_value_('rule', node)
        if value is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            self.rule = value
            self.validate_e_roadMarkRule(self.rule)    # validate type e_roadMarkRule
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            value = self.gds_parse_double(value, node, 'space')
            self.space = value
            self.validate_t_grEqZero(self.space)    # validate type t_grEqZero
        value = find_attr_value_('tOffset', node)
        if value is not None and 'tOffset' not in already_processed:
            already_processed.add('tOffset')
            value = self.gds_parse_double(value, node, 'tOffset')
            self.tOffset = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
            self.validate_t_grZero(self.width)    # validate type t_grZero
        super(t_road_lanes_laneSection_lcr_lane_roadMark_type_line, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_lcr_lane_roadMark_type_line, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_lcr_lane_roadMark_type_line


class t_road_lanes_laneSection_left(_OpenDriveElement):
    """t_road_lanes_laneSection_left -- For easier navigation through an ASAM OpenDRIVE road description, the lanes within a lane section are grouped into left, center, and right lanes. Each lane section shall contain one
    <
    center
    >
    element and at least one
    <
    right
    >
    or
    <
    left
    >
    element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, lane=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_left"), self).__init__( **kwargs_)
        if lane is None:
            self.lane = []
        else:
            self.lane = lane
        self.lane_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_left)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_left.subclass:
            return t_road_lanes_laneSection_left.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_left(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.lane or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_lanes_laneSection_left, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_left', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_left')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_left':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_left')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_left', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_left'):
        super(t_road_lanes_laneSection_left, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_left')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_left', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_left, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for lane_ in self.lane:
            namespaceprefix_ = self.lane_nsprefix_ + ':' if (UseCapturedNS_ and self.lane_nsprefix_) else ''
            lane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lane', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_lanes_laneSection_left, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lane':
            obj_ = t_road_lanes_laneSection_left_lane.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lane.append(obj_)
            obj_.original_tagname_ = 'lane'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_lanes_laneSection_left, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_lanes_laneSection_left


class t_road_lanes_laneSection_lr_lane(_OpenDriveElement):
    """t_road_lanes_laneSection_lr_lane -- Lane elements are included in left/center/right elements. Lane elements should represent the lanes from left to right, that is, with descending ID.
    level -- "true" = keep lane on level, that is, do not apply superelevation;
    "false" = apply superelevation to this lane (default, also used if attribute level is missing)
    type -- Type of the lane
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, level=None, type_=None, link=None, border=None, width=None, roadMark=None, material=None, speed=None, access=None, height=None, rule=None, dataQuality=None, include=None, userData=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lr_lane"), self).__init__(extensiontype_,  **kwargs_)
        self.level = _cast(None, level)
        self.level_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.link = link
        self.link_nsprefix_ = None
        if border is None:
            self.border = []
        else:
            self.border = border
        self.border_nsprefix_ = None
        if width is None:
            self.width = []
        else:
            self.width = width
        self.width_nsprefix_ = None
        if roadMark is None:
            self.roadMark = []
        else:
            self.roadMark = roadMark
        self.roadMark_nsprefix_ = None
        if material is None:
            self.material = []
        else:
            self.material = material
        self.material_nsprefix_ = None
        if speed is None:
            self.speed = []
        else:
            self.speed = speed
        self.speed_nsprefix_ = None
        if access is None:
            self.access = []
        else:
            self.access = access
        self.access_nsprefix_ = None
        if height is None:
            self.height = []
        else:
            self.height = height
        self.height_nsprefix_ = None
        if rule is None:
            self.rule = []
        else:
            self.rule = rule
        self.rule_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane.subclass:
            return t_road_lanes_laneSection_lr_lane.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_bool(self, value):
        # Validate type t_bool, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['true', 'false']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on t_bool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_laneType(self, value):
        # Validate type e_laneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['shoulder', 'border', 'driving', 'stop', 'none', 'restricted', 'parking', 'median', 'biking', 'sidewalk', 'curb', 'exit', 'entry', 'onRamp', 'offRamp', 'connectingRamp', 'bidirectional', 'special1', 'special2', 'special3', 'roadWorks', 'tram', 'rail', 'bus', 'taxi', 'HOV', 'mwyEntry', 'mwyExit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_laneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.link is not None or
            self.border or
            self.width or
            self.roadMark or
            self.material or
            self.speed or
            self.access or
            self.height or
            self.rule or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_lanes_laneSection_lr_lane, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lr_lane':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane'):
        super(t_road_lanes_laneSection_lr_lane, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane')
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.level), input_name='level')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lr_lane, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.link is not None:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            self.link.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for border_ in self.border:
            namespaceprefix_ = self.border_nsprefix_ + ':' if (UseCapturedNS_ and self.border_nsprefix_) else ''
            border_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='border', pretty_print=pretty_print)
        for width_ in self.width:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            width_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        for roadMark_ in self.roadMark:
            namespaceprefix_ = self.roadMark_nsprefix_ + ':' if (UseCapturedNS_ and self.roadMark_nsprefix_) else ''
            roadMark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='roadMark', pretty_print=pretty_print)
        for material_ in self.material:
            namespaceprefix_ = self.material_nsprefix_ + ':' if (UseCapturedNS_ and self.material_nsprefix_) else ''
            material_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='material', pretty_print=pretty_print)
        for speed_ in self.speed:
            namespaceprefix_ = self.speed_nsprefix_ + ':' if (UseCapturedNS_ and self.speed_nsprefix_) else ''
            speed_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='speed', pretty_print=pretty_print)
        for access_ in self.access:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            access_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='access', pretty_print=pretty_print)
        for height_ in self.height:
            namespaceprefix_ = self.height_nsprefix_ + ':' if (UseCapturedNS_ and self.height_nsprefix_) else ''
            height_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='height', pretty_print=pretty_print)
        for rule_ in self.rule:
            namespaceprefix_ = self.rule_nsprefix_ + ':' if (UseCapturedNS_ and self.rule_nsprefix_) else ''
            rule_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rule', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
            self.validate_t_bool(self.level)    # validate type t_bool
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_laneType(self.type_)    # validate type e_laneType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(t_road_lanes_laneSection_lr_lane, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'link':
            obj_ = t_road_lanes_laneSection_lcr_lane_link.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.link = obj_
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'border':
            obj_ = t_road_lanes_laneSection_lr_lane_border.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.border.append(obj_)
            obj_.original_tagname_ = 'border'
        elif nodeName_ == 'width':
            obj_ = t_road_lanes_laneSection_lr_lane_width.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width.append(obj_)
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'roadMark':
            obj_ = t_road_lanes_laneSection_lcr_lane_roadMark.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.roadMark.append(obj_)
            obj_.original_tagname_ = 'roadMark'
        elif nodeName_ == 'material':
            obj_ = t_road_lanes_laneSection_lr_lane_material.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.material.append(obj_)
            obj_.original_tagname_ = 'material'
        elif nodeName_ == 'speed':
            obj_ = t_road_lanes_laneSection_lr_lane_speed.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.speed.append(obj_)
            obj_.original_tagname_ = 'speed'
        elif nodeName_ == 'access':
            obj_ = t_road_lanes_laneSection_lr_lane_access.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access.append(obj_)
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'height':
            obj_ = t_road_lanes_laneSection_lr_lane_height.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.height.append(obj_)
            obj_.original_tagname_ = 'height'
        elif nodeName_ == 'rule':
            obj_ = t_road_lanes_laneSection_lr_lane_rule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rule.append(obj_)
            obj_.original_tagname_ = 'rule'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_lanes_laneSection_lr_lane, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_lanes_laneSection_lr_lane


class t_road_lanes_laneSection_lr_lane_access(_OpenDriveElement):
    """t_road_lanes_laneSection_lr_lane_access -- Defines access restrictions for certain types of road users.
    Each element is valid in direction of the increasing s coordinate until a new element is defined. If multiple elements are defined, they shall be listed in ascending order.
    restriction -- Identifier of the participant to whom the restriction applies
    rule -- Specifies whether the participant given in the attribute @restriction is allowed or denied access to the given lane
    sOffset -- s-coordinate of start position, relative to the position of the preceding
    <
    laneSection
    >
    element
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, restriction=None, rule=None, sOffset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lr_lane_access"), self).__init__( **kwargs_)
        self.restriction = _cast(None, restriction)
        self.restriction_nsprefix_ = None
        self.rule = _cast(None, rule)
        self.rule_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_access)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_access.subclass:
            return t_road_lanes_laneSection_lr_lane_access.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_access(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_accessRestrictionType(self, value):
        # Validate type e_accessRestrictionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['simulator', 'autonomousTraffic', 'pedestrian', 'passengerCar', 'bus', 'delivery', 'emergency', 'taxi', 'throughTraffic', 'truck', 'bicycle', 'motorcycle', 'none', 'trucks']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_accessRestrictionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_road_lanes_laneSection_lr_lane_access_rule(self, value):
        # Validate type e_road_lanes_laneSection_lr_lane_access_rule, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['allow', 'deny']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_road_lanes_laneSection_lr_lane_access_rule' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_lr_lane_access, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_access', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_access')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lr_lane_access':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_access')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_access', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_access'):
        super(t_road_lanes_laneSection_lr_lane_access, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_access')
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.add('restriction')
            outfile.write(' restriction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.restriction), input_name='restriction')), ))
        if self.rule is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            outfile.write(' rule=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rule), input_name='rule')), ))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_access', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lr_lane_access, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.add('restriction')
            self.restriction = value
            self.validate_e_accessRestrictionType(self.restriction)    # validate type e_accessRestrictionType
        value = find_attr_value_('rule', node)
        if value is not None and 'rule' not in already_processed:
            already_processed.add('rule')
            self.rule = value
            self.validate_e_road_lanes_laneSection_lr_lane_access_rule(self.rule)    # validate type e_road_lanes_laneSection_lr_lane_access_rule
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        super(t_road_lanes_laneSection_lr_lane_access, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_lr_lane_access, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_lr_lane_access


class t_road_lanes_laneSection_lr_lane_border(_OpenDriveElement):
    """t_road_lanes_laneSection_lr_lane_border -- Lane borders are another method to describe the width of lanes. Instead of defining the width directly, lane borders describe the outer limits of a lane, independent of the parameters of their inner borders. In this case, inner lanes are defined as lanes which have the same sign for their ID as the lane currently defined, but with a smaller absolute value for their ID.
    Especially when road data is derived from automatic measurements, this type of definition is easier than specifying the lane width because it avoids creating many lane sections.
    Lane width and lane border elements are mutually exclusive within the same lane group. If both width and lane border elements are present for a lane section in the ASAM OpenDRIVE file, the application shall use the information from the
    <
    width
    >
    elements.
    In ASAM OpenDRIVE, lane borders are represented by the
    <
    border
    >
    element within the
    <
    lane
    >
    element.
    a -- Polynom parameter a, border position at @s (ds=0)
    b -- Polynom parameter b
    c -- Polynom parameter c
    d -- Polynom parameter d
    sOffset -- s-coordinate of start position of the
    <
    border
    >
    element , relative to the position of the preceding
    <
    laneSection
    >
    element
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, a=None, b=None, c=None, d=None, sOffset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lr_lane_border"), self).__init__( **kwargs_)
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_border)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_border.subclass:
            return t_road_lanes_laneSection_lr_lane_border.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_border(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_lr_lane_border, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_border', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_border')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lr_lane_border':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_border')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_border', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_border'):
        super(t_road_lanes_laneSection_lr_lane_border, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_border')
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_border', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lr_lane_border, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        super(t_road_lanes_laneSection_lr_lane_border, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_lr_lane_border, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_lr_lane_border


class t_road_lanes_laneSection_lr_lane_height(_OpenDriveElement):
    """t_road_lanes_laneSection_lr_lane_height -- Lane height shall be defined along the h-coordinate. Lane height may be used to elevate a lane independent from the road elevation. Lane height is used to implement small-scale elevation such as raising pedestrian walkways. Lane height is specified as offset from the road (including elevation, superelevation, shape) in z direction.
    inner -- Inner offset from road level
    outer -- Outer offset from road level
    sOffset -- s-coordinate of start position, relative to the position of the preceding
    <
    laneSection
    >
    element
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, inner=None, outer=None, sOffset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lr_lane_height"), self).__init__( **kwargs_)
        self.inner = _cast(float, inner)
        self.inner_nsprefix_ = None
        self.outer = _cast(float, outer)
        self.outer_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_height)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_height.subclass:
            return t_road_lanes_laneSection_lr_lane_height.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_height(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_lr_lane_height, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_height', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_height')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lr_lane_height':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_height')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_height', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_height'):
        super(t_road_lanes_laneSection_lr_lane_height, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_height')
        if self.inner is not None and 'inner' not in already_processed:
            already_processed.add('inner')
            outfile.write(' inner="%s"' % self.gds_format_double(self.inner, input_name='inner'))
        if self.outer is not None and 'outer' not in already_processed:
            already_processed.add('outer')
            outfile.write(' outer="%s"' % self.gds_format_double(self.outer, input_name='outer'))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_height', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lr_lane_height, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inner', node)
        if value is not None and 'inner' not in already_processed:
            already_processed.add('inner')
            value = self.gds_parse_double(value, node, 'inner')
            self.inner = value
        value = find_attr_value_('outer', node)
        if value is not None and 'outer' not in already_processed:
            already_processed.add('outer')
            value = self.gds_parse_double(value, node, 'outer')
            self.outer = value
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        super(t_road_lanes_laneSection_lr_lane_height, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_lr_lane_height, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_lr_lane_height


class t_road_lanes_laneSection_lr_lane_material(_OpenDriveElement):
    """t_road_lanes_laneSection_lr_lane_material -- Stores information about the material of lanes. Each element is valid until a new element is defined. If multiple elements are defined, they must be listed in ascending order.
    friction -- Friction coefficient
    roughness -- Roughness, for example, for sound and motion systems
    sOffset -- s-coordinate of start position, relative to the position of the preceding
    <
    laneSection
    >
    element
    surface -- Surface material code, depending on application
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, friction=None, roughness=None, sOffset=None, surface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lr_lane_material"), self).__init__( **kwargs_)
        self.friction = _cast(float, friction)
        self.friction_nsprefix_ = None
        self.roughness = _cast(float, roughness)
        self.roughness_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.surface = _cast(None, surface)
        self.surface_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_material)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_material.subclass:
            return t_road_lanes_laneSection_lr_lane_material.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_material(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_lr_lane_material, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_material', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_material')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lr_lane_material':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_material')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_material', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_material'):
        super(t_road_lanes_laneSection_lr_lane_material, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_material')
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction="%s"' % self.gds_format_double(self.friction, input_name='friction'))
        if self.roughness is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            outfile.write(' roughness="%s"' % self.gds_format_double(self.roughness, input_name='roughness'))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.surface is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            outfile.write(' surface=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.surface), input_name='surface')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_material', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lr_lane_material, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            value = self.gds_parse_double(value, node, 'friction')
            self.friction = value
            self.validate_t_grEqZero(self.friction)    # validate type t_grEqZero
        value = find_attr_value_('roughness', node)
        if value is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            value = self.gds_parse_double(value, node, 'roughness')
            self.roughness = value
            self.validate_t_grEqZero(self.roughness)    # validate type t_grEqZero
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('surface', node)
        if value is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            self.surface = value
        super(t_road_lanes_laneSection_lr_lane_material, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_lr_lane_material, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_lr_lane_material


class t_road_lanes_laneSection_lr_lane_rule(_OpenDriveElement):
    """t_road_lanes_laneSection_lr_lane_rule -- Used to add rules that are not covered by any of the other lane attributes that are described in this specification.
    sOffset -- s-coordinate of start position, relative to the position of the preceding
    <
    laneSection
    >
    element
    value -- Free text; currently recommended values are
    "no stopping at any time"
    "disabled parking"
    "car pool"
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, sOffset=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lr_lane_rule"), self).__init__( **kwargs_)
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_rule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_rule.subclass:
            return t_road_lanes_laneSection_lr_lane_rule.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_rule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_lr_lane_rule, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_rule', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_rule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lr_lane_rule':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_rule')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_rule', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_rule'):
        super(t_road_lanes_laneSection_lr_lane_rule, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_rule')
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_rule', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lr_lane_rule, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(t_road_lanes_laneSection_lr_lane_rule, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_lr_lane_rule, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_lr_lane_rule


class t_road_lanes_laneSection_lr_lane_speed(_OpenDriveElement):
    """t_road_lanes_laneSection_lr_lane_speed -- Defines the maximum allowed speed on a given lane. Each element is valid in direction of the increasing s-coordinate until a new element is defined.
    max -- Maximum allowed speed. If the attribute unit is not specified, m/s is used as default.
    sOffset -- s-coordinate of start position, relative to the position of the preceding
    <
    laneSection
    >
    element
    unit -- Unit of the attribute max
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, max=None, sOffset=None, unit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lr_lane_speed"), self).__init__( **kwargs_)
        self.max = _cast(float, max)
        self.max_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_speed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_speed.subclass:
            return t_road_lanes_laneSection_lr_lane_speed.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_speed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_unitSpeed(self, value):
        # Validate type e_unitSpeed, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['m/s', 'mph', 'km/h']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_unitSpeed' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_lr_lane_speed, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_speed', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_speed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lr_lane_speed':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_speed')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_speed', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_speed'):
        super(t_road_lanes_laneSection_lr_lane_speed, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_speed')
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max="%s"' % self.gds_format_double(self.max, input_name='max'))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_speed', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lr_lane_speed, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            value = self.gds_parse_double(value, node, 'max')
            self.max = value
            self.validate_t_grEqZero(self.max)    # validate type t_grEqZero
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_e_unitSpeed(self.unit)    # validate type e_unitSpeed
        super(t_road_lanes_laneSection_lr_lane_speed, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_lr_lane_speed, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_lr_lane_speed


class t_road_lanes_laneSection_lr_lane_width(_OpenDriveElement):
    """t_road_lanes_laneSection_lr_lane_width -- The width of a lane is defined along the t-coordinate. The width of a lane may change within a lane section.
    Lane width and lane border elements are mutually exclusive within the same lane group. If both width and lane border elements are present for a lane section in the ASAM OpenDRIVE file, the application must use the information from the
    <
    width
    >
    elements.
    In ASAM OpenDRIVE, lane width is described by the
    <
    width
    >
    element within the
    <
    lane
    >
    element.
    a -- Polynom parameter a, width at @s (ds=0)
    b -- Polynom parameter b
    c -- Polynom parameter c
    d -- Polynom parameter d
    sOffset -- s-coordinate of start position of the
    <
    width
    >
    element, relative to the position of the preceding
    <
    laneSection
    >
    element
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, a=None, b=None, c=None, d=None, sOffset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_lr_lane_width"), self).__init__( **kwargs_)
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.c = _cast(float, c)
        self.c_nsprefix_ = None
        self.d = _cast(float, d)
        self.d_nsprefix_ = None
        self.sOffset = _cast(float, sOffset)
        self.sOffset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_lr_lane_width)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_lr_lane_width.subclass:
            return t_road_lanes_laneSection_lr_lane_width.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_lr_lane_width(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_lr_lane_width, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_width', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_lr_lane_width')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_lr_lane_width':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_width')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_lr_lane_width', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_lr_lane_width'):
        super(t_road_lanes_laneSection_lr_lane_width, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_lr_lane_width')
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c="%s"' % self.gds_format_double(self.c, input_name='c'))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_double(self.d, input_name='d'))
        if self.sOffset is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            outfile.write(' sOffset="%s"' % self.gds_format_double(self.sOffset, input_name='sOffset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_lr_lane_width', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_lr_lane_width, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_double(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_double(value, node, 'b')
            self.b = value
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            value = self.gds_parse_double(value, node, 'c')
            self.c = value
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            value = self.gds_parse_double(value, node, 'd')
            self.d = value
        value = find_attr_value_('sOffset', node)
        if value is not None and 'sOffset' not in already_processed:
            already_processed.add('sOffset')
            value = self.gds_parse_double(value, node, 'sOffset')
            self.sOffset = value
            self.validate_t_grEqZero(self.sOffset)    # validate type t_grEqZero
        super(t_road_lanes_laneSection_lr_lane_width, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_lr_lane_width, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_lr_lane_width


class t_road_lanes_laneSection_right(_OpenDriveElement):
    """t_road_lanes_laneSection_right -- For easier navigation through an ASAM OpenDRIVE road description, the lanes within a lane section are grouped into left, center, and right lanes. Each lane section shall contain one
    <
    center
    >
    element and at least one
    <
    right
    >
    or
    <
    left
    >
    element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, lane=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_right"), self).__init__( **kwargs_)
        if lane is None:
            self.lane = []
        else:
            self.lane = lane
        self.lane_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_right)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_right.subclass:
            return t_road_lanes_laneSection_right.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_right(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.lane or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_lanes_laneSection_right, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_right', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_right')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_right':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_right')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_right', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_right'):
        super(t_road_lanes_laneSection_right, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_right')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_right', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_right, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for lane_ in self.lane:
            namespaceprefix_ = self.lane_nsprefix_ + ':' if (UseCapturedNS_ and self.lane_nsprefix_) else ''
            lane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lane', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_lanes_laneSection_right, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lane':
            obj_ = t_road_lanes_laneSection_right_lane.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lane.append(obj_)
            obj_.original_tagname_ = 'lane'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_lanes_laneSection_right, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_lanes_laneSection_right


class t_road_lanes_laneSection_right_lane(t_road_lanes_laneSection_lr_lane):
    """t_road_lanes_laneSection_right_lane -- Lane elements are included in left/center/right elements. Lane elements should represent the lanes from left to right, that is, with descending ID.
    id -- ID of the lane
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = t_road_lanes_laneSection_lr_lane
    def __init__(self, level=None, type_=None, link=None, border=None, width=None, roadMark=None, material=None, speed=None, access=None, height=None, rule=None, dataQuality=None, include=None, userData=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_right_lane"), self).__init__(level, type_, link, border, width, roadMark, material, speed, access, height, rule, dataQuality, include, userData,  **kwargs_)
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_right_lane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_right_lane.subclass:
            return t_road_lanes_laneSection_right_lane.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_right_lane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_right_lane, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_right_lane', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_right_lane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_right_lane':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_right_lane')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_right_lane', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_right_lane'):
        super(t_road_lanes_laneSection_right_lane, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_right_lane')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_right_lane', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_right_lane, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id >= 0:
                raise_parse_error(node, 'Invalid NegativeInteger')
        super(t_road_lanes_laneSection_right_lane, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_right_lane, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_right_lane


class t_road_objects_object_laneValidity(_OpenDriveElement):
    """t_road_objects_object_laneValidity -- May replace the default validity with explicit validity information for an object. Multiple validity elements may be defined per object.
    fromLane -- Minimum ID of the lanes for which the object is valid
    toLane -- Maximum ID of the lanes for which the object is valid
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, fromLane=None, toLane=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_laneValidity"), self).__init__( **kwargs_)
        self.fromLane = _cast(int, fromLane)
        self.fromLane_nsprefix_ = None
        self.toLane = _cast(int, toLane)
        self.toLane_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_laneValidity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_laneValidity.subclass:
            return t_road_objects_object_laneValidity.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_laneValidity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_objects_object_laneValidity, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_laneValidity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_laneValidity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_laneValidity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_laneValidity')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_laneValidity', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_laneValidity'):
        super(t_road_objects_object_laneValidity, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_laneValidity')
        if self.fromLane is not None and 'fromLane' not in already_processed:
            already_processed.add('fromLane')
            outfile.write(' fromLane="%s"' % self.gds_format_integer(self.fromLane, input_name='fromLane'))
        if self.toLane is not None and 'toLane' not in already_processed:
            already_processed.add('toLane')
            outfile.write(' toLane="%s"' % self.gds_format_integer(self.toLane, input_name='toLane'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_laneValidity', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_laneValidity, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fromLane', node)
        if value is not None and 'fromLane' not in already_processed:
            already_processed.add('fromLane')
            self.fromLane = self.gds_parse_integer(value, node, 'fromLane')
        value = find_attr_value_('toLane', node)
        if value is not None and 'toLane' not in already_processed:
            already_processed.add('toLane')
            self.toLane = self.gds_parse_integer(value, node, 'toLane')
        super(t_road_objects_object_laneValidity, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_objects_object_laneValidity, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_objects_object_laneValidity


class t_road_lanes_laneSection_left_lane(t_road_lanes_laneSection_lr_lane):
    """t_road_lanes_laneSection_left_lane -- Lane elements are included in left/center/right elements. Lane elements should represent the lanes from left to right, that is, with descending ID.
    id -- ID of the lane
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = t_road_lanes_laneSection_lr_lane
    def __init__(self, level=None, type_=None, link=None, border=None, width=None, roadMark=None, material=None, speed=None, access=None, height=None, rule=None, dataQuality=None, include=None, userData=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_left_lane"), self).__init__(level, type_, link, border, width, roadMark, material, speed, access, height, rule, dataQuality, include, userData,  **kwargs_)
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_left_lane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_left_lane.subclass:
            return t_road_lanes_laneSection_left_lane.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_left_lane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_left_lane, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_left_lane', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_left_lane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_left_lane':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_left_lane')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_left_lane', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_left_lane'):
        super(t_road_lanes_laneSection_left_lane, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_left_lane')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_left_lane', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_left_lane, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(t_road_lanes_laneSection_left_lane, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_left_lane, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_left_lane


class t_road_lanes_laneSection_center_lane(t_road_lanes_laneSection_lr_lane):
    """t_road_lanes_laneSection_center_lane -- Lane elements are included in left/center/right elements. Lane elements should represent the lanes from left to right, that is, with descending ID.
    id -- ID of the lane
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = t_road_lanes_laneSection_lr_lane
    def __init__(self, level=None, type_=None, link=None, border=None, width=None, roadMark=None, material=None, speed=None, access=None, height=None, rule=None, dataQuality=None, include=None, userData=None, id=0, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_lanes_laneSection_center_lane"), self).__init__(level, type_, link, border, width, roadMark, material, speed, access, height, rule, dataQuality, include, userData,  **kwargs_)
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_lanes_laneSection_center_lane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_lanes_laneSection_center_lane.subclass:
            return t_road_lanes_laneSection_center_lane.subclass(*args_, **kwargs_)
        else:
            return t_road_lanes_laneSection_center_lane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_lanes_laneSection_center_lane, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_center_lane', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_lanes_laneSection_center_lane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_lanes_laneSection_center_lane':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_center_lane')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_lanes_laneSection_center_lane', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_lanes_laneSection_center_lane'):
        super(t_road_lanes_laneSection_center_lane, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_lanes_laneSection_center_lane')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_lanes_laneSection_center_lane', fromsubclass_=False, pretty_print=True):
        super(t_road_lanes_laneSection_center_lane, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
        super(t_road_lanes_laneSection_center_lane, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_lanes_laneSection_center_lane, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_lanes_laneSection_center_lane


class t_road_objects_tunnel(_OpenDriveElement):
    """t_road_objects_tunnel -- Tunnels are modeled as objects in ASAM OpenDRIVE. Tunnels apply to the entire cross section of the road within the given range unless a lane validity element with further restrictions is provided as child element.
    daylight -- Degree of daylight intruding the tunnel. Depends on the application.
    id -- Unique ID within database
    length -- Length of the tunnel (in s-direction)
    lighting -- Degree of artificial tunnel lighting. Depends on the application.
    name -- Name of the tunnel. May be chosen freely.
    s -- s-coordinate
    type -- Type of tunnel
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, daylight=None, id=None, length=None, lighting=None, name=None, s=None, type_=None, validity=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_tunnel"), self).__init__( **kwargs_)
        self.daylight = _cast(float, daylight)
        self.daylight_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.lighting = _cast(float, lighting)
        self.lighting_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_tunnel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_tunnel.subclass:
            return t_road_objects_tunnel.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_tunnel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_zeroOne(self, value):
        # Validate type t_zeroOne, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_zeroOne' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on t_zeroOne' % {"value": value, "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_tunnelType(self, value):
        # Validate type e_tunnelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'underpass']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_tunnelType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.validity or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_objects_tunnel, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_tunnel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_tunnel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_tunnel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_tunnel')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_tunnel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_tunnel'):
        super(t_road_objects_tunnel, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_tunnel')
        if self.daylight is not None and 'daylight' not in already_processed:
            already_processed.add('daylight')
            outfile.write(' daylight="%s"' % self.gds_format_double(self.daylight, input_name='daylight'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.lighting is not None and 'lighting' not in already_processed:
            already_processed.add('lighting')
            outfile.write(' lighting="%s"' % self.gds_format_double(self.lighting, input_name='lighting'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_tunnel', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_tunnel, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('daylight', node)
        if value is not None and 'daylight' not in already_processed:
            already_processed.add('daylight')
            value = self.gds_parse_double(value, node, 'daylight')
            self.daylight = value
            self.validate_t_zeroOne(self.daylight)    # validate type t_zeroOne
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
            self.validate_t_grEqZero(self.length)    # validate type t_grEqZero
        value = find_attr_value_('lighting', node)
        if value is not None and 'lighting' not in already_processed:
            already_processed.add('lighting')
            value = self.gds_parse_double(value, node, 'lighting')
            self.lighting = value
            self.validate_t_zeroOne(self.lighting)    # validate type t_zeroOne
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_tunnelType(self.type_)    # validate type e_tunnelType
        super(t_road_objects_tunnel, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_objects_tunnel, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects_tunnel


class t_road_objects_objectReference(_OpenDriveElement):
    """t_road_objects_objectReference -- It is possible to link an object with one or more roads, signals or other objects using a
    <
    objectReference
    >
    element. The referenced objects require a unique ID. The object reference element consists of a main element and an optional lane validity element. The rules for validity elements are the same as for objects.
    id -- Unique ID of the referred object within the database
    orientation -- "+" = valid in positive s-direction
    "-" = valid in negative s-direction
    "none" = valid in both directions
    s -- s-coordinate
    t -- t-coordinate
    validLength -- Validity of the object along s-axis
    (0.0 for point object)
    zOffset -- z offset relative to the elevation of the reference line
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, orientation=None, s=None, t=None, validLength=None, zOffset=None, validity=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_objectReference"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.validLength = _cast(float, validLength)
        self.validLength_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_objectReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_objectReference.subclass:
            return t_road_objects_objectReference.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_objectReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_orientation(self, value):
        # Validate type e_orientation, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_orientation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.validity or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_objects_objectReference, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_objectReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_objectReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_objectReference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_objectReference')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_objectReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_objectReference'):
        super(t_road_objects_objectReference, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_objectReference')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if self.validLength is not None and 'validLength' not in already_processed:
            already_processed.add('validLength')
            outfile.write(' validLength="%s"' % self.gds_format_double(self.validLength, input_name='validLength'))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_objectReference', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_objectReference, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_e_orientation(self.orientation)    # validate type e_orientation
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        value = find_attr_value_('validLength', node)
        if value is not None and 'validLength' not in already_processed:
            already_processed.add('validLength')
            value = self.gds_parse_double(value, node, 'validLength')
            self.validLength = value
            self.validate_t_grEqZero(self.validLength)    # validate type t_grEqZero
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            value = self.gds_parse_double(value, node, 'zOffset')
            self.zOffset = value
        super(t_road_objects_objectReference, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_objects_objectReference, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects_objectReference


class t_road_objects_object_surface_CRG(_OpenDriveElement):
    """t_road_objects_object_surface_CRG -- Elevation data described in {GLO_VAR_STA_ASAM_OpenCRG} are represented by the
    <
    CRG
    >
    element within the
    <
    surface
    >
    element.
    file -- Name of the file containing the CRG data.
    hideRoadSurfaceCRG -- Determines if the object CRG hides the road surface CRG. Default is true.
    zScale -- z-scale factor for the surface description (default = 1.0).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, file=None, hideRoadSurfaceCRG=None, zScale=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_surface_CRG"), self).__init__( **kwargs_)
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
        self.hideRoadSurfaceCRG = _cast(None, hideRoadSurfaceCRG)
        self.hideRoadSurfaceCRG_nsprefix_ = None
        self.zScale = _cast(float, zScale)
        self.zScale_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_surface_CRG)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_surface_CRG.subclass:
            return t_road_objects_object_surface_CRG.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_surface_CRG(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_bool(self, value):
        # Validate type t_bool, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['true', 'false']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on t_bool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_objects_object_surface_CRG, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_surface_CRG', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_surface_CRG')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_surface_CRG':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_surface_CRG')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_surface_CRG', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_surface_CRG'):
        super(t_road_objects_object_surface_CRG, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_surface_CRG')
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
        if self.hideRoadSurfaceCRG is not None and 'hideRoadSurfaceCRG' not in already_processed:
            already_processed.add('hideRoadSurfaceCRG')
            outfile.write(' hideRoadSurfaceCRG=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.hideRoadSurfaceCRG), input_name='hideRoadSurfaceCRG')), ))
        if self.zScale is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            outfile.write(' zScale="%s"' % self.gds_format_double(self.zScale, input_name='zScale'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_surface_CRG', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_surface_CRG, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
        value = find_attr_value_('hideRoadSurfaceCRG', node)
        if value is not None and 'hideRoadSurfaceCRG' not in already_processed:
            already_processed.add('hideRoadSurfaceCRG')
            self.hideRoadSurfaceCRG = value
            self.validate_t_bool(self.hideRoadSurfaceCRG)    # validate type t_bool
        value = find_attr_value_('zScale', node)
        if value is not None and 'zScale' not in already_processed:
            already_processed.add('zScale')
            value = self.gds_parse_double(value, node, 'zScale')
            self.zScale = value
        super(t_road_objects_object_surface_CRG, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_objects_object_surface_CRG, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_objects_object_surface_CRG


class t_road_objects_object_surface(_OpenDriveElement):
    """t_road_objects_object_surface -- Used to describe the road surface elevation of an object.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, CRG=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_surface"), self).__init__( **kwargs_)
        self.CRG = CRG
        self.CRG_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_surface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_surface.subclass:
            return t_road_objects_object_surface.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_surface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.CRG is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_objects_object_surface, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_surface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_surface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_surface':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_surface')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_surface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_surface'):
        super(t_road_objects_object_surface, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_surface')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_surface', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_surface, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CRG is not None:
            namespaceprefix_ = self.CRG_nsprefix_ + ':' if (UseCapturedNS_ and self.CRG_nsprefix_) else ''
            self.CRG.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CRG', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_objects_object_surface, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CRG':
            obj_ = t_road_objects_object_surface_CRG.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CRG = obj_
            obj_.original_tagname_ = 'CRG'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_objects_object_surface, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects_object_surface


class t_road_objects_object_repeat(_OpenDriveElement):
    """t_road_objects_object_repeat -- To avoid lengthy XML code, objects of the same type may be repeated. Attributes of the repeated object shall overrule the attributes from the original object. If attributes are omitted in the repeated objects, the attributes from the original object apply.
    distance -- Distance between two instances of the object;
    If this value is zero, then the object is treated like a continuous feature, for example, a guard rail, a wall, etc.
    heightEnd -- Height of the object at @s + @length
    heightStart -- Height of the object at @s
    length -- Length of the repeat area, along the reference line in s-direction.
    lengthEnd -- Length of the object at @s + @length
    lengthStart -- Length of the object at @s
    radiusEnd -- Radius of the object at @s + @length
    radiusStart -- Radius of the object at @s
    s -- s-coordinate of start position, overrides the corresponding argument in the original
    <
    object
    >
    record
    tEnd -- Lateral offset of object's reference point at @s + @length
    tStart -- Lateral offset of objects reference point at @s
    widthEnd -- Width of the object at @s + @length
    widthStart -- Width of the object at @s
    zOffsetEnd -- z-offset of the object at @s + @length, relative to the elevation of the reference line
    zOffsetStart -- z-offset of the object at @s, relative to the elevation of the reference line
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, distance=None, heightEnd=None, heightStart=None, length=None, lengthEnd=None, lengthStart=None, radiusEnd=None, radiusStart=None, s=None, tEnd=None, tStart=None, widthEnd=None, widthStart=None, zOffsetEnd=None, zOffsetStart=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_repeat"), self).__init__( **kwargs_)
        self.distance = _cast(float, distance)
        self.distance_nsprefix_ = None
        self.heightEnd = _cast(float, heightEnd)
        self.heightEnd_nsprefix_ = None
        self.heightStart = _cast(float, heightStart)
        self.heightStart_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.lengthEnd = _cast(float, lengthEnd)
        self.lengthEnd_nsprefix_ = None
        self.lengthStart = _cast(float, lengthStart)
        self.lengthStart_nsprefix_ = None
        self.radiusEnd = _cast(float, radiusEnd)
        self.radiusEnd_nsprefix_ = None
        self.radiusStart = _cast(float, radiusStart)
        self.radiusStart_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.tEnd = _cast(float, tEnd)
        self.tEnd_nsprefix_ = None
        self.tStart = _cast(float, tStart)
        self.tStart_nsprefix_ = None
        self.widthEnd = _cast(float, widthEnd)
        self.widthEnd_nsprefix_ = None
        self.widthStart = _cast(float, widthStart)
        self.widthStart_nsprefix_ = None
        self.zOffsetEnd = _cast(float, zOffsetEnd)
        self.zOffsetEnd_nsprefix_ = None
        self.zOffsetStart = _cast(float, zOffsetStart)
        self.zOffsetStart_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_repeat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_repeat.subclass:
            return t_road_objects_object_repeat.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_repeat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_objects_object_repeat, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_repeat', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_repeat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_repeat':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_repeat')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_repeat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_repeat'):
        super(t_road_objects_object_repeat, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_repeat')
        if self.distance is not None and 'distance' not in already_processed:
            already_processed.add('distance')
            outfile.write(' distance="%s"' % self.gds_format_double(self.distance, input_name='distance'))
        if self.heightEnd is not None and 'heightEnd' not in already_processed:
            already_processed.add('heightEnd')
            outfile.write(' heightEnd="%s"' % self.gds_format_double(self.heightEnd, input_name='heightEnd'))
        if self.heightStart is not None and 'heightStart' not in already_processed:
            already_processed.add('heightStart')
            outfile.write(' heightStart="%s"' % self.gds_format_double(self.heightStart, input_name='heightStart'))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.lengthEnd is not None and 'lengthEnd' not in already_processed:
            already_processed.add('lengthEnd')
            outfile.write(' lengthEnd="%s"' % self.gds_format_double(self.lengthEnd, input_name='lengthEnd'))
        if self.lengthStart is not None and 'lengthStart' not in already_processed:
            already_processed.add('lengthStart')
            outfile.write(' lengthStart="%s"' % self.gds_format_double(self.lengthStart, input_name='lengthStart'))
        if self.radiusEnd is not None and 'radiusEnd' not in already_processed:
            already_processed.add('radiusEnd')
            outfile.write(' radiusEnd="%s"' % self.gds_format_double(self.radiusEnd, input_name='radiusEnd'))
        if self.radiusStart is not None and 'radiusStart' not in already_processed:
            already_processed.add('radiusStart')
            outfile.write(' radiusStart="%s"' % self.gds_format_double(self.radiusStart, input_name='radiusStart'))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.tEnd is not None and 'tEnd' not in already_processed:
            already_processed.add('tEnd')
            outfile.write(' tEnd="%s"' % self.gds_format_double(self.tEnd, input_name='tEnd'))
        if self.tStart is not None and 'tStart' not in already_processed:
            already_processed.add('tStart')
            outfile.write(' tStart="%s"' % self.gds_format_double(self.tStart, input_name='tStart'))
        if self.widthEnd is not None and 'widthEnd' not in already_processed:
            already_processed.add('widthEnd')
            outfile.write(' widthEnd="%s"' % self.gds_format_double(self.widthEnd, input_name='widthEnd'))
        if self.widthStart is not None and 'widthStart' not in already_processed:
            already_processed.add('widthStart')
            outfile.write(' widthStart="%s"' % self.gds_format_double(self.widthStart, input_name='widthStart'))
        if self.zOffsetEnd is not None and 'zOffsetEnd' not in already_processed:
            already_processed.add('zOffsetEnd')
            outfile.write(' zOffsetEnd="%s"' % self.gds_format_double(self.zOffsetEnd, input_name='zOffsetEnd'))
        if self.zOffsetStart is not None and 'zOffsetStart' not in already_processed:
            already_processed.add('zOffsetStart')
            outfile.write(' zOffsetStart="%s"' % self.gds_format_double(self.zOffsetStart, input_name='zOffsetStart'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_repeat', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_repeat, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distance', node)
        if value is not None and 'distance' not in already_processed:
            already_processed.add('distance')
            value = self.gds_parse_double(value, node, 'distance')
            self.distance = value
            self.validate_t_grEqZero(self.distance)    # validate type t_grEqZero
        value = find_attr_value_('heightEnd', node)
        if value is not None and 'heightEnd' not in already_processed:
            already_processed.add('heightEnd')
            value = self.gds_parse_double(value, node, 'heightEnd')
            self.heightEnd = value
            self.validate_t_grEqZero(self.heightEnd)    # validate type t_grEqZero
        value = find_attr_value_('heightStart', node)
        if value is not None and 'heightStart' not in already_processed:
            already_processed.add('heightStart')
            value = self.gds_parse_double(value, node, 'heightStart')
            self.heightStart = value
            self.validate_t_grEqZero(self.heightStart)    # validate type t_grEqZero
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
            self.validate_t_grEqZero(self.length)    # validate type t_grEqZero
        value = find_attr_value_('lengthEnd', node)
        if value is not None and 'lengthEnd' not in already_processed:
            already_processed.add('lengthEnd')
            value = self.gds_parse_double(value, node, 'lengthEnd')
            self.lengthEnd = value
            self.validate_t_grEqZero(self.lengthEnd)    # validate type t_grEqZero
        value = find_attr_value_('lengthStart', node)
        if value is not None and 'lengthStart' not in already_processed:
            already_processed.add('lengthStart')
            value = self.gds_parse_double(value, node, 'lengthStart')
            self.lengthStart = value
            self.validate_t_grEqZero(self.lengthStart)    # validate type t_grEqZero
        value = find_attr_value_('radiusEnd', node)
        if value is not None and 'radiusEnd' not in already_processed:
            already_processed.add('radiusEnd')
            value = self.gds_parse_double(value, node, 'radiusEnd')
            self.radiusEnd = value
            self.validate_t_grEqZero(self.radiusEnd)    # validate type t_grEqZero
        value = find_attr_value_('radiusStart', node)
        if value is not None and 'radiusStart' not in already_processed:
            already_processed.add('radiusStart')
            value = self.gds_parse_double(value, node, 'radiusStart')
            self.radiusStart = value
            self.validate_t_grEqZero(self.radiusStart)    # validate type t_grEqZero
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('tEnd', node)
        if value is not None and 'tEnd' not in already_processed:
            already_processed.add('tEnd')
            value = self.gds_parse_double(value, node, 'tEnd')
            self.tEnd = value
        value = find_attr_value_('tStart', node)
        if value is not None and 'tStart' not in already_processed:
            already_processed.add('tStart')
            value = self.gds_parse_double(value, node, 'tStart')
            self.tStart = value
        value = find_attr_value_('widthEnd', node)
        if value is not None and 'widthEnd' not in already_processed:
            already_processed.add('widthEnd')
            value = self.gds_parse_double(value, node, 'widthEnd')
            self.widthEnd = value
            self.validate_t_grEqZero(self.widthEnd)    # validate type t_grEqZero
        value = find_attr_value_('widthStart', node)
        if value is not None and 'widthStart' not in already_processed:
            already_processed.add('widthStart')
            value = self.gds_parse_double(value, node, 'widthStart')
            self.widthStart = value
            self.validate_t_grEqZero(self.widthStart)    # validate type t_grEqZero
        value = find_attr_value_('zOffsetEnd', node)
        if value is not None and 'zOffsetEnd' not in already_processed:
            already_processed.add('zOffsetEnd')
            value = self.gds_parse_double(value, node, 'zOffsetEnd')
            self.zOffsetEnd = value
        value = find_attr_value_('zOffsetStart', node)
        if value is not None and 'zOffsetStart' not in already_processed:
            already_processed.add('zOffsetStart')
            value = self.gds_parse_double(value, node, 'zOffsetStart')
            self.zOffsetStart = value
        super(t_road_objects_object_repeat, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_objects_object_repeat, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_objects_object_repeat


class t_road_objects_object_parkingSpace(_OpenDriveElement):
    """t_road_objects_object_parkingSpace -- Details for a parking space may be added to the
    <
    object
    >
    element.
    access -- Access definitions for the parking space. Parking spaces tagged with "women" and "handicapped" are vehicles of type car.
    restrictions -- Free text, depending on application
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, access=None, restrictions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_parkingSpace"), self).__init__( **kwargs_)
        self.access = _cast(None, access)
        self.access_nsprefix_ = None
        self.restrictions = _cast(None, restrictions)
        self.restrictions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_parkingSpace)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_parkingSpace.subclass:
            return t_road_objects_object_parkingSpace.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_parkingSpace(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_road_objects_object_parkingSpace_access(self, value):
        # Validate type e_road_objects_object_parkingSpace_access, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['all', 'car', 'women', 'handicapped', 'bus', 'truck', 'electric', 'residents']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_road_objects_object_parkingSpace_access' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_objects_object_parkingSpace, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_parkingSpace', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_parkingSpace')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_parkingSpace':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_parkingSpace')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_parkingSpace', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_parkingSpace'):
        super(t_road_objects_object_parkingSpace, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_parkingSpace')
        if self.access is not None and 'access' not in already_processed:
            already_processed.add('access')
            outfile.write(' access=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.access), input_name='access')), ))
        if self.restrictions is not None and 'restrictions' not in already_processed:
            already_processed.add('restrictions')
            outfile.write(' restrictions=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.restrictions), input_name='restrictions')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_parkingSpace', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_parkingSpace, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('access', node)
        if value is not None and 'access' not in already_processed:
            already_processed.add('access')
            self.access = value
            self.validate_e_road_objects_object_parkingSpace_access(self.access)    # validate type e_road_objects_object_parkingSpace_access
        value = find_attr_value_('restrictions', node)
        if value is not None and 'restrictions' not in already_processed:
            already_processed.add('restrictions')
            self.restrictions = value
        super(t_road_objects_object_parkingSpace, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_objects_object_parkingSpace, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_objects_object_parkingSpace


class t_road_objects_object_outlines_outline_cornerRoad(_OpenDriveElement):
    """t_road_objects_object_outlines_outline_cornerRoad -- Defines a corner point on the object
    ’
    s outline in road coordinates.
    dz -- dz of the corner relative to road reference line
    height -- Height of the object at this corner, along the z-axis
    id -- ID of the outline point. Must be unique within one outline
    s -- s-coordinate of the corner
    t -- t-coordinate of the corner
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, dz=None, height=None, id=None, s=None, t=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_outlines_outline_cornerRoad"), self).__init__( **kwargs_)
        self.dz = _cast(float, dz)
        self.dz_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_outlines_outline_cornerRoad)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_outlines_outline_cornerRoad.subclass:
            return t_road_objects_object_outlines_outline_cornerRoad.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_outlines_outline_cornerRoad(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_objects_object_outlines_outline_cornerRoad, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline_cornerRoad', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_outlines_outline_cornerRoad')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_outlines_outline_cornerRoad':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines_outline_cornerRoad')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_outlines_outline_cornerRoad', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_outlines_outline_cornerRoad'):
        super(t_road_objects_object_outlines_outline_cornerRoad, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines_outline_cornerRoad')
        if self.dz is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            outfile.write(' dz="%s"' % self.gds_format_double(self.dz, input_name='dz'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline_cornerRoad', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_outlines_outline_cornerRoad, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dz', node)
        if value is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            value = self.gds_parse_double(value, node, 'dz')
            self.dz = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_double(value, node, 'height')
            self.height = value
            self.validate_t_grEqZero(self.height)    # validate type t_grEqZero
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        super(t_road_objects_object_outlines_outline_cornerRoad, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_objects_object_outlines_outline_cornerRoad, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_objects_object_outlines_outline_cornerRoad


class t_road_objects_object_outlines_outline_cornerLocal(_OpenDriveElement):
    """t_road_objects_object_outlines_outline_cornerLocal -- Used to describe complex forms of objects. Defines a corner point on the object outline relative to the object pivot point in local u/v-coordinates. The insertion point and the orientation of the object are given by the @s, @t, @zOffset and @hdg attributes of the  element.
    height -- Height of the object at this corner, along the z-axis
    id -- ID of the outline point. Shall be unique within one outline.
    u -- Local u-coordinate of the corner
    v -- Local v-coordinate of the corner
    z -- Local z-coordinate of the corner
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, height=None, id=None, u=None, v=None, z=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_outlines_outline_cornerLocal"), self).__init__( **kwargs_)
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.u = _cast(float, u)
        self.u_nsprefix_ = None
        self.v = _cast(float, v)
        self.v_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_outlines_outline_cornerLocal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_outlines_outline_cornerLocal.subclass:
            return t_road_objects_object_outlines_outline_cornerLocal.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_outlines_outline_cornerLocal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_objects_object_outlines_outline_cornerLocal, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline_cornerLocal', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_outlines_outline_cornerLocal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_outlines_outline_cornerLocal':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines_outline_cornerLocal')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_outlines_outline_cornerLocal', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_outlines_outline_cornerLocal'):
        super(t_road_objects_object_outlines_outline_cornerLocal, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines_outline_cornerLocal')
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.u is not None and 'u' not in already_processed:
            already_processed.add('u')
            outfile.write(' u="%s"' % self.gds_format_double(self.u, input_name='u'))
        if self.v is not None and 'v' not in already_processed:
            already_processed.add('v')
            outfile.write(' v="%s"' % self.gds_format_double(self.v, input_name='v'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline_cornerLocal', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_outlines_outline_cornerLocal, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_double(value, node, 'height')
            self.height = value
            self.validate_t_grEqZero(self.height)    # validate type t_grEqZero
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('u', node)
        if value is not None and 'u' not in already_processed:
            already_processed.add('u')
            value = self.gds_parse_double(value, node, 'u')
            self.u = value
        value = find_attr_value_('v', node)
        if value is not None and 'v' not in already_processed:
            already_processed.add('v')
            value = self.gds_parse_double(value, node, 'v')
            self.v = value
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            value = self.gds_parse_double(value, node, 'z')
            self.z = value
        super(t_road_objects_object_outlines_outline_cornerLocal, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_objects_object_outlines_outline_cornerLocal, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_objects_object_outlines_outline_cornerLocal


class t_road_objects_object_outlines_outline(_OpenDriveElement):
    """t_road_objects_object_outlines_outline -- Defines a series of corner points, including the height of the object relative to the road reference line. For areas, the points should be listed in counter-clockwise order.
    An
    <
    outline
    >
    element shall be followed by one or more
    <
    cornerRoad
    >
    element or by one or more
    <
    cornerLocal
    >
    element.
    ASAM OpenDRIVE 1.4 outline definitions (without
    <
    outlines
    >
    parent element) shall still be supported.
    closed -- If true, the outline describes an area, not a linear feature
    fillType -- Type used to fill the area inside the outline
    id -- ID of the outline. Must be unique within one object.
    laneType -- Describes the lane type of the outline
    outer -- Defines if outline is an outer outline of the object
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, closed=None, fillType=None, id=None, laneType=None, outer=None, cornerRoad=None, cornerLocal=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_outlines_outline"), self).__init__( **kwargs_)
        self.closed = _cast(None, closed)
        self.closed_nsprefix_ = None
        self.fillType = _cast(None, fillType)
        self.fillType_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.laneType = _cast(None, laneType)
        self.laneType_nsprefix_ = None
        self.outer = _cast(None, outer)
        self.outer_nsprefix_ = None
        if cornerRoad is None:
            self.cornerRoad = []
        else:
            self.cornerRoad = cornerRoad
        self.cornerRoad_nsprefix_ = None
        if cornerLocal is None:
            self.cornerLocal = []
        else:
            self.cornerLocal = cornerLocal
        self.cornerLocal_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_outlines_outline)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_outlines_outline.subclass:
            return t_road_objects_object_outlines_outline.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_outlines_outline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_bool(self, value):
        # Validate type t_bool, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['true', 'false']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on t_bool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_outlineFillType(self, value):
        # Validate type e_outlineFillType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['grass', 'concrete', 'cobble', 'asphalt', 'pavement', 'gravel', 'soil']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_outlineFillType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_laneType(self, value):
        # Validate type e_laneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['shoulder', 'border', 'driving', 'stop', 'none', 'restricted', 'parking', 'median', 'biking', 'sidewalk', 'curb', 'exit', 'entry', 'onRamp', 'offRamp', 'connectingRamp', 'bidirectional', 'special1', 'special2', 'special3', 'roadWorks', 'tram', 'rail', 'bus', 'taxi', 'HOV', 'mwyEntry', 'mwyExit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_laneType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.cornerRoad or
            self.cornerLocal or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_objects_object_outlines_outline, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_outlines_outline')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_outlines_outline':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines_outline')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_outlines_outline', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_outlines_outline'):
        super(t_road_objects_object_outlines_outline, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines_outline')
        if self.closed is not None and 'closed' not in already_processed:
            already_processed.add('closed')
            outfile.write(' closed=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.closed), input_name='closed')), ))
        if self.fillType is not None and 'fillType' not in already_processed:
            already_processed.add('fillType')
            outfile.write(' fillType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fillType), input_name='fillType')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.laneType is not None and 'laneType' not in already_processed:
            already_processed.add('laneType')
            outfile.write(' laneType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.laneType), input_name='laneType')), ))
        if self.outer is not None and 'outer' not in already_processed:
            already_processed.add('outer')
            outfile.write(' outer=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outer), input_name='outer')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines_outline', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_outlines_outline, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cornerRoad_ in self.cornerRoad:
            namespaceprefix_ = self.cornerRoad_nsprefix_ + ':' if (UseCapturedNS_ and self.cornerRoad_nsprefix_) else ''
            cornerRoad_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cornerRoad', pretty_print=pretty_print)
        for cornerLocal_ in self.cornerLocal:
            namespaceprefix_ = self.cornerLocal_nsprefix_ + ':' if (UseCapturedNS_ and self.cornerLocal_nsprefix_) else ''
            cornerLocal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cornerLocal', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('closed', node)
        if value is not None and 'closed' not in already_processed:
            already_processed.add('closed')
            self.closed = value
            self.validate_t_bool(self.closed)    # validate type t_bool
        value = find_attr_value_('fillType', node)
        if value is not None and 'fillType' not in already_processed:
            already_processed.add('fillType')
            self.fillType = value
            self.validate_e_outlineFillType(self.fillType)    # validate type e_outlineFillType
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('laneType', node)
        if value is not None and 'laneType' not in already_processed:
            already_processed.add('laneType')
            self.laneType = value
            self.validate_e_laneType(self.laneType)    # validate type e_laneType
        value = find_attr_value_('outer', node)
        if value is not None and 'outer' not in already_processed:
            already_processed.add('outer')
            self.outer = value
            self.validate_t_bool(self.outer)    # validate type t_bool
        super(t_road_objects_object_outlines_outline, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cornerRoad':
            obj_ = t_road_objects_object_outlines_outline_cornerRoad.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cornerRoad.append(obj_)
            obj_.original_tagname_ = 'cornerRoad'
        elif nodeName_ == 'cornerLocal':
            obj_ = t_road_objects_object_outlines_outline_cornerLocal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cornerLocal.append(obj_)
            obj_.original_tagname_ = 'cornerLocal'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_objects_object_outlines_outline, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects_object_outlines_outline


class t_road_objects_object_outlines(_OpenDriveElement):
    """t_road_objects_object_outlines -- An outline defines a series of corner points, including the height of the object relative to the road reference line. The inner area of the described outline may be filled with a filling type, such as grass, concrete, asphalt, or pavement.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, outline=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_outlines"), self).__init__( **kwargs_)
        if outline is None:
            self.outline = []
        else:
            self.outline = outline
        self.outline_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_outlines)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_outlines.subclass:
            return t_road_objects_object_outlines.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_outlines(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.outline or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_objects_object_outlines, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_outlines')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_outlines':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_outlines', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_outlines'):
        super(t_road_objects_object_outlines, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_outlines')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_outlines', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_outlines, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for outline_ in self.outline:
            namespaceprefix_ = self.outline_nsprefix_ + ':' if (UseCapturedNS_ and self.outline_nsprefix_) else ''
            outline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='outline', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_objects_object_outlines, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'outline':
            obj_ = t_road_objects_object_outlines_outline.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.outline.append(obj_)
            obj_.original_tagname_ = 'outline'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_objects_object_outlines, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects_object_outlines


class t_road_objects_object_material(_OpenDriveElement):
    """t_road_objects_object_material -- Describes the material properties of objects, for example, patches that are part of the road surface but deviate from the standard road material. Supersedes the material specified in the
    <
    road material
    >
    element and is valid only within the outline of the parent road object.
    friction -- Friction value, depending on application
    roughness -- Roughness, for example, for sound and motion systems, depending on application
    surface -- Surface material code, depending on application
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, friction=None, roughness=None, surface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_material"), self).__init__( **kwargs_)
        self.friction = _cast(float, friction)
        self.friction_nsprefix_ = None
        self.roughness = _cast(float, roughness)
        self.roughness_nsprefix_ = None
        self.surface = _cast(None, surface)
        self.surface_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_material)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_material.subclass:
            return t_road_objects_object_material.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_material(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(t_road_objects_object_material, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_material', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_material')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_material':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_material')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_material', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_material'):
        super(t_road_objects_object_material, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_material')
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction="%s"' % self.gds_format_double(self.friction, input_name='friction'))
        if self.roughness is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            outfile.write(' roughness="%s"' % self.gds_format_double(self.roughness, input_name='roughness'))
        if self.surface is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            outfile.write(' surface=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.surface), input_name='surface')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_material', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_material, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            value = self.gds_parse_double(value, node, 'friction')
            self.friction = value
            self.validate_t_grEqZero(self.friction)    # validate type t_grEqZero
        value = find_attr_value_('roughness', node)
        if value is not None and 'roughness' not in already_processed:
            already_processed.add('roughness')
            value = self.gds_parse_double(value, node, 'roughness')
            self.roughness = value
            self.validate_t_grEqZero(self.roughness)    # validate type t_grEqZero
        value = find_attr_value_('surface', node)
        if value is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            self.surface = value
        super(t_road_objects_object_material, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_objects_object_material, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_objects_object_material


class t_road_objects_object_markings_marking_cornerReference(_OpenDriveElement):
    """t_road_objects_object_markings_marking_cornerReference -- Specifies a point by referencing an existing outline point.
    id -- Identifier of the referenced outline point
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_markings_marking_cornerReference"), self).__init__( **kwargs_)
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_markings_marking_cornerReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_markings_marking_cornerReference.subclass:
            return t_road_objects_object_markings_marking_cornerReference.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_markings_marking_cornerReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            super(t_road_objects_object_markings_marking_cornerReference, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings_marking_cornerReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_markings_marking_cornerReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_markings_marking_cornerReference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_markings_marking_cornerReference')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_markings_marking_cornerReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_markings_marking_cornerReference'):
        super(t_road_objects_object_markings_marking_cornerReference, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_markings_marking_cornerReference')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings_marking_cornerReference', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_markings_marking_cornerReference, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        super(t_road_objects_object_markings_marking_cornerReference, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(t_road_objects_object_markings_marking_cornerReference, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class t_road_objects_object_markings_marking_cornerReference


class t_road_objects_object_markings_marking(_OpenDriveElement):
    """t_road_objects_object_markings_marking -- Specifies a marking that is either attached to one side of the object bounding box or referencing outline points.
    color -- Color of the marking
    lineLength -- Length of the visible part
    side -- Side of the bounding box described in
    <
    object
    >
    element in the local coordinate system u/v
    spaceLength -- Length of the gap between the visible parts
    startOffset -- Lateral offset in u-direction from start of bounding box side where the first marking starts
    stopOffset -- Lateral offset in u-direction from end of bounding box side where the marking ends
    weight -- Optical "weight" of the marking
    width -- Width of the marking
    zOffset -- Height of road mark above the road, i.e. thickness of the road mark
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, color=None, lineLength=None, side=None, spaceLength=None, startOffset=None, stopOffset=None, weight=None, width=None, zOffset=None, cornerReference=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_markings_marking"), self).__init__( **kwargs_)
        self.color = _cast(None, color)
        self.color_nsprefix_ = None
        self.lineLength = _cast(float, lineLength)
        self.lineLength_nsprefix_ = None
        self.side = _cast(None, side)
        self.side_nsprefix_ = None
        self.spaceLength = _cast(float, spaceLength)
        self.spaceLength_nsprefix_ = None
        self.startOffset = _cast(float, startOffset)
        self.startOffset_nsprefix_ = None
        self.stopOffset = _cast(float, stopOffset)
        self.stopOffset_nsprefix_ = None
        self.weight = _cast(None, weight)
        self.weight_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        if cornerReference is None:
            self.cornerReference = []
        else:
            self.cornerReference = cornerReference
        self.cornerReference_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_markings_marking)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_markings_marking.subclass:
            return t_road_objects_object_markings_marking.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_markings_marking(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_roadMarkColor(self, value):
        # Validate type e_roadMarkColor, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'blue', 'green', 'red', 'white', 'yellow', 'orange', 'violet']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_roadMarkColor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grZero(self, value):
        # Validate type t_grZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on t_grZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_sideType(self, value):
        # Validate type e_sideType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'right', 'front', 'rear']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_sideType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_roadMarkWeight(self, value):
        # Validate type e_roadMarkWeight, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['standard', 'bold']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_roadMarkWeight' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.cornerReference or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_objects_object_markings_marking, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings_marking', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_markings_marking')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_markings_marking':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_markings_marking')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_markings_marking', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_markings_marking'):
        super(t_road_objects_object_markings_marking, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_markings_marking')
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')), ))
        if self.lineLength is not None and 'lineLength' not in already_processed:
            already_processed.add('lineLength')
            outfile.write(' lineLength="%s"' % self.gds_format_double(self.lineLength, input_name='lineLength'))
        if self.side is not None and 'side' not in already_processed:
            already_processed.add('side')
            outfile.write(' side=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.side), input_name='side')), ))
        if self.spaceLength is not None and 'spaceLength' not in already_processed:
            already_processed.add('spaceLength')
            outfile.write(' spaceLength="%s"' % self.gds_format_double(self.spaceLength, input_name='spaceLength'))
        if self.startOffset is not None and 'startOffset' not in already_processed:
            already_processed.add('startOffset')
            outfile.write(' startOffset="%s"' % self.gds_format_double(self.startOffset, input_name='startOffset'))
        if self.stopOffset is not None and 'stopOffset' not in already_processed:
            already_processed.add('stopOffset')
            outfile.write(' stopOffset="%s"' % self.gds_format_double(self.stopOffset, input_name='stopOffset'))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.weight), input_name='weight')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings_marking', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_markings_marking, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cornerReference_ in self.cornerReference:
            namespaceprefix_ = self.cornerReference_nsprefix_ + ':' if (UseCapturedNS_ and self.cornerReference_nsprefix_) else ''
            cornerReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cornerReference', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value
            self.validate_e_roadMarkColor(self.color)    # validate type e_roadMarkColor
        value = find_attr_value_('lineLength', node)
        if value is not None and 'lineLength' not in already_processed:
            already_processed.add('lineLength')
            value = self.gds_parse_double(value, node, 'lineLength')
            self.lineLength = value
            self.validate_t_grZero(self.lineLength)    # validate type t_grZero
        value = find_attr_value_('side', node)
        if value is not None and 'side' not in already_processed:
            already_processed.add('side')
            self.side = value
            self.validate_e_sideType(self.side)    # validate type e_sideType
        value = find_attr_value_('spaceLength', node)
        if value is not None and 'spaceLength' not in already_processed:
            already_processed.add('spaceLength')
            value = self.gds_parse_double(value, node, 'spaceLength')
            self.spaceLength = value
            self.validate_t_grEqZero(self.spaceLength)    # validate type t_grEqZero
        value = find_attr_value_('startOffset', node)
        if value is not None and 'startOffset' not in already_processed:
            already_processed.add('startOffset')
            value = self.gds_parse_double(value, node, 'startOffset')
            self.startOffset = value
        value = find_attr_value_('stopOffset', node)
        if value is not None and 'stopOffset' not in already_processed:
            already_processed.add('stopOffset')
            value = self.gds_parse_double(value, node, 'stopOffset')
            self.stopOffset = value
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            self.weight = value
            self.validate_e_roadMarkWeight(self.weight)    # validate type e_roadMarkWeight
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
            self.validate_t_grZero(self.width)    # validate type t_grZero
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            value = self.gds_parse_double(value, node, 'zOffset')
            self.zOffset = value
            self.validate_t_grEqZero(self.zOffset)    # validate type t_grEqZero
        super(t_road_objects_object_markings_marking, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cornerReference':
            obj_ = t_road_objects_object_markings_marking_cornerReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cornerReference.append(obj_)
            obj_.original_tagname_ = 'cornerReference'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_objects_object_markings_marking, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects_object_markings_marking


class t_road_objects_object_markings(_OpenDriveElement):
    """t_road_objects_object_markings -- Describes the appearance of the parking space with multiple marking elements.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, marking=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_markings"), self).__init__( **kwargs_)
        if marking is None:
            self.marking = []
        else:
            self.marking = marking
        self.marking_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_markings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_markings.subclass:
            return t_road_objects_object_markings.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_markings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.marking or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_objects_object_markings, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_markings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_markings':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_markings')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_markings', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_markings'):
        super(t_road_objects_object_markings, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_markings')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_markings', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_markings, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for marking_ in self.marking:
            namespaceprefix_ = self.marking_nsprefix_ + ':' if (UseCapturedNS_ and self.marking_nsprefix_) else ''
            marking_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='marking', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_objects_object_markings, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'marking':
            obj_ = t_road_objects_object_markings_marking.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.marking.append(obj_)
            obj_.original_tagname_ = 'marking'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_objects_object_markings, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects_object_markings


class t_road_objects_object_borders_border(_OpenDriveElement):
    """t_road_objects_object_borders_border -- Specifies a border along certain outline points.
    outlineId -- ID of the outline to use
    type -- Appearance of border
    useCompleteOutline -- Use all outline points for border.
    “
    true
    ”
    is used as default.
    width -- Border width
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, outlineId=None, type_=None, useCompleteOutline=None, width=None, cornerReference=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_borders_border"), self).__init__( **kwargs_)
        self.outlineId = _cast(int, outlineId)
        self.outlineId_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.useCompleteOutline = _cast(None, useCompleteOutline)
        self.useCompleteOutline_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        if cornerReference is None:
            self.cornerReference = []
        else:
            self.cornerReference = cornerReference
        self.cornerReference_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_borders_border)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_borders_border.subclass:
            return t_road_objects_object_borders_border.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_borders_border(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_e_borderType(self, value):
        # Validate type e_borderType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['concrete', 'curb']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_borderType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_bool(self, value):
        # Validate type t_bool, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['true', 'false']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on t_bool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.cornerReference or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_objects_object_borders_border, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_borders_border', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_borders_border')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_borders_border':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_borders_border')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_borders_border', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_borders_border'):
        super(t_road_objects_object_borders_border, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_borders_border')
        if self.outlineId is not None and 'outlineId' not in already_processed:
            already_processed.add('outlineId')
            outfile.write(' outlineId="%s"' % self.gds_format_integer(self.outlineId, input_name='outlineId'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.useCompleteOutline is not None and 'useCompleteOutline' not in already_processed:
            already_processed.add('useCompleteOutline')
            outfile.write(' useCompleteOutline=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.useCompleteOutline), input_name='useCompleteOutline')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_borders_border', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_borders_border, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cornerReference_ in self.cornerReference:
            namespaceprefix_ = self.cornerReference_nsprefix_ + ':' if (UseCapturedNS_ and self.cornerReference_nsprefix_) else ''
            cornerReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cornerReference', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('outlineId', node)
        if value is not None and 'outlineId' not in already_processed:
            already_processed.add('outlineId')
            self.outlineId = self.gds_parse_integer(value, node, 'outlineId')
            if self.outlineId < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_borderType(self.type_)    # validate type e_borderType
        value = find_attr_value_('useCompleteOutline', node)
        if value is not None and 'useCompleteOutline' not in already_processed:
            already_processed.add('useCompleteOutline')
            self.useCompleteOutline = value
            self.validate_t_bool(self.useCompleteOutline)    # validate type t_bool
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
            self.validate_t_grEqZero(self.width)    # validate type t_grEqZero
        super(t_road_objects_object_borders_border, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cornerReference':
            obj_ = t_road_objects_object_markings_marking_cornerReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cornerReference.append(obj_)
            obj_.original_tagname_ = 'cornerReference'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_objects_object_borders_border, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects_object_borders_border


class t_road_objects_object_borders(_OpenDriveElement):
    """t_road_objects_object_borders -- Objects may have a border, that is, a frame of a defined width. Different border types are available.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, border=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object_borders"), self).__init__( **kwargs_)
        if border is None:
            self.border = []
        else:
            self.border = border
        self.border_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object_borders)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object_borders.subclass:
            return t_road_objects_object_borders.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object_borders(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.border or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_objects_object_borders, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_borders', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object_borders')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object_borders':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_borders')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object_borders', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object_borders'):
        super(t_road_objects_object_borders, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object_borders')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object_borders', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object_borders, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for border_ in self.border:
            namespaceprefix_ = self.border_nsprefix_ + ':' if (UseCapturedNS_ and self.border_nsprefix_) else ''
            border_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='border', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_objects_object_borders, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'border':
            obj_ = t_road_objects_object_borders_border.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.border.append(obj_)
            obj_.original_tagname_ = 'border'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_objects_object_borders, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects_object_borders


class t_road_objects_object(_OpenDriveElement):
    """t_road_objects_object -- Describes common 3D objects that have a reference to a given road. Objects are items that influence a road by expanding, delimiting, and supplementing its course. The most common examples are parking spaces, crosswalks, and traffic barriers.
    There are two ways to describe the bounding box of objects.
    - For an angular object: definition of the width, length and height.
    - For a circular object: definition of the radius and height.
    dynamic -- Indicates whether the object is dynamic or static, default value is
    “
    no
    ”
    (static). Dynamic object cannot change its position.
    hdg -- Heading angle of the object relative to road direction
    height -- Height of the object's bounding box. @height is defined in the local coordinate system u/v along the z-axis
    id -- Unique ID within database
    length -- Length of the object's bounding box, alternative to @radius.
    @length is defined in the local coordinate system u/v along the v-axis
    name -- Name of the object. May be chosen freely.
    orientation -- "+" = valid in positive s-direction
    "-" = valid in negative s-direction
    "none" = valid in both directions
    (does not affect the heading)
    perpToRoad -- Alternative to @pitch and @roll. If true, the object is vertically perpendicular to the road surface at all points and @pitch and @roll are ignored. Default is false.
    pitch -- Pitch angle relative to the x/y-plane
    radius -- radius of the circular object's bounding box, alternative to @length and @width. @radius is defined in the local coordinate system u/v
    roll -- Roll angle relative to the x/y-plane
    s -- s-coordinate of object's origin
    subtype -- Variant of a type
    t -- t-coordinate of object's origin
    type -- Type of object. For a parking space, the
    <
    parkingSpace
    >
    element may be used additionally.
    validLength -- Validity of object along s-axis (0.0 for point object)
    width -- Width of the object's bounding box, alternative to @radius.
    @width is defined in the local coordinate system u/v along the u-axis
    zOffset -- z-offset of object's origin relative to the elevation of the reference line
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, dynamic=None, hdg=None, height=None, id=None, length=None, name=None, orientation=None, perpToRoad=None, pitch=None, radius=None, roll=None, s=None, subtype=None, t=None, type_=None, validLength=None, width=None, zOffset=None, repeat=None, outline=None, outlines=None, material=None, validity=None, parkingSpace=None, markings=None, borders=None, dataQuality=None, include=None, userData=None, surface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_object"), self).__init__( **kwargs_)
        self.dynamic = _cast(None, dynamic)
        self.dynamic_nsprefix_ = None
        self.hdg = _cast(float, hdg)
        self.hdg_nsprefix_ = None
        self.height = _cast(float, height)
        self.height_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.orientation = _cast(None, orientation)
        self.orientation_nsprefix_ = None
        self.perpToRoad = _cast(None, perpToRoad)
        self.perpToRoad_nsprefix_ = None
        self.pitch = _cast(float, pitch)
        self.pitch_nsprefix_ = None
        self.radius = _cast(float, radius)
        self.radius_nsprefix_ = None
        self.roll = _cast(float, roll)
        self.roll_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.subtype = _cast(None, subtype)
        self.subtype_nsprefix_ = None
        self.t = _cast(float, t)
        self.t_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.validLength = _cast(float, validLength)
        self.validLength_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.zOffset = _cast(float, zOffset)
        self.zOffset_nsprefix_ = None
        if repeat is None:
            self.repeat = []
        else:
            self.repeat = repeat
        self.repeat_nsprefix_ = None
        self.outline = outline
        self.outline_nsprefix_ = None
        self.outlines = outlines
        self.outlines_nsprefix_ = None
        if material is None:
            self.material = []
        else:
            self.material = material
        self.material_nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        self.parkingSpace = parkingSpace
        self.parkingSpace_nsprefix_ = None
        self.markings = markings
        self.markings_nsprefix_ = None
        self.borders = borders
        self.borders_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
        self.surface = surface
        self.surface_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_object)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_object.subclass:
            return t_road_objects_object.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_yesNo(self, value):
        # Validate type t_yesNo, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on t_yesNo' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_t_grZero(self, value):
        # Validate type t_grZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on t_grZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_orientation(self, value):
        # Validate type e_orientation, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_orientation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_t_bool(self, value):
        # Validate type t_bool, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['true', 'false']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on t_bool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_e_objectType(self, value):
        # Validate type e_objectType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'obstacle', 'car', 'pole', 'tree', 'vegetation', 'barrier', 'building', 'parkingSpace', 'patch', 'railing', 'trafficIsland', 'crosswalk', 'streetLamp', 'gantry', 'soundBarrier', 'van', 'bus', 'trailer', 'bike', 'motorbike', 'tram', 'train', 'pedestrian', 'wind', 'roadMark']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_objectType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.repeat or
            self.outline is not None or
            self.outlines is not None or
            self.material or
            self.validity or
            self.parkingSpace is not None or
            self.markings is not None or
            self.borders is not None or
            self.dataQuality or
            self.include or
            self.userData or
            self.surface is not None or
            super(t_road_objects_object, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_object')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_object':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_object', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_object'):
        super(t_road_objects_object, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_object')
        if self.dynamic is not None and 'dynamic' not in already_processed:
            already_processed.add('dynamic')
            outfile.write(' dynamic=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dynamic), input_name='dynamic')), ))
        if self.hdg is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            outfile.write(' hdg="%s"' % self.gds_format_double(self.hdg, input_name='hdg'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.orientation), input_name='orientation')), ))
        if self.perpToRoad is not None and 'perpToRoad' not in already_processed:
            already_processed.add('perpToRoad')
            outfile.write(' perpToRoad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.perpToRoad), input_name='perpToRoad')), ))
        if self.pitch is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            outfile.write(' pitch="%s"' % self.gds_format_double(self.pitch, input_name='pitch'))
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            outfile.write(' radius="%s"' % self.gds_format_double(self.radius, input_name='radius'))
        if self.roll is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            outfile.write(' roll="%s"' % self.gds_format_double(self.roll, input_name='roll'))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.subtype is not None and 'subtype' not in already_processed:
            already_processed.add('subtype')
            outfile.write(' subtype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.subtype), input_name='subtype')), ))
        if self.t is not None and 't' not in already_processed:
            already_processed.add('t')
            outfile.write(' t="%s"' % self.gds_format_double(self.t, input_name='t'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.validLength is not None and 'validLength' not in already_processed:
            already_processed.add('validLength')
            outfile.write(' validLength="%s"' % self.gds_format_double(self.validLength, input_name='validLength'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.zOffset is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            outfile.write(' zOffset="%s"' % self.gds_format_double(self.zOffset, input_name='zOffset'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_object', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_object, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for repeat_ in self.repeat:
            namespaceprefix_ = self.repeat_nsprefix_ + ':' if (UseCapturedNS_ and self.repeat_nsprefix_) else ''
            repeat_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='repeat', pretty_print=pretty_print)
        if self.outline is not None:
            namespaceprefix_ = self.outline_nsprefix_ + ':' if (UseCapturedNS_ and self.outline_nsprefix_) else ''
            self.outline.export(outfile, level, namespaceprefix_, namespacedef_='', name_='outline', pretty_print=pretty_print)
        if self.outlines is not None:
            namespaceprefix_ = self.outlines_nsprefix_ + ':' if (UseCapturedNS_ and self.outlines_nsprefix_) else ''
            self.outlines.export(outfile, level, namespaceprefix_, namespacedef_='', name_='outlines', pretty_print=pretty_print)
        for material_ in self.material:
            namespaceprefix_ = self.material_nsprefix_ + ':' if (UseCapturedNS_ and self.material_nsprefix_) else ''
            material_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='material', pretty_print=pretty_print)
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        if self.parkingSpace is not None:
            namespaceprefix_ = self.parkingSpace_nsprefix_ + ':' if (UseCapturedNS_ and self.parkingSpace_nsprefix_) else ''
            self.parkingSpace.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parkingSpace', pretty_print=pretty_print)
        if self.markings is not None:
            namespaceprefix_ = self.markings_nsprefix_ + ':' if (UseCapturedNS_ and self.markings_nsprefix_) else ''
            self.markings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='markings', pretty_print=pretty_print)
        if self.borders is not None:
            namespaceprefix_ = self.borders_nsprefix_ + ':' if (UseCapturedNS_ and self.borders_nsprefix_) else ''
            self.borders.export(outfile, level, namespaceprefix_, namespacedef_='', name_='borders', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
        if self.surface is not None:
            namespaceprefix_ = self.surface_nsprefix_ + ':' if (UseCapturedNS_ and self.surface_nsprefix_) else ''
            self.surface.export(outfile, level, namespaceprefix_, namespacedef_='', name_='surface', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dynamic', node)
        if value is not None and 'dynamic' not in already_processed:
            already_processed.add('dynamic')
            self.dynamic = value
            self.validate_t_yesNo(self.dynamic)    # validate type t_yesNo
        value = find_attr_value_('hdg', node)
        if value is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            value = self.gds_parse_double(value, node, 'hdg')
            self.hdg = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            value = self.gds_parse_double(value, node, 'height')
            self.height = value
            self.validate_t_grEqZero(self.height)    # validate type t_grEqZero
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
            self.validate_t_grZero(self.length)    # validate type t_grZero
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            self.orientation = value
            self.validate_e_orientation(self.orientation)    # validate type e_orientation
        value = find_attr_value_('perpToRoad', node)
        if value is not None and 'perpToRoad' not in already_processed:
            already_processed.add('perpToRoad')
            self.perpToRoad = value
            self.validate_t_bool(self.perpToRoad)    # validate type t_bool
        value = find_attr_value_('pitch', node)
        if value is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            value = self.gds_parse_double(value, node, 'pitch')
            self.pitch = value
        value = find_attr_value_('radius', node)
        if value is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            value = self.gds_parse_double(value, node, 'radius')
            self.radius = value
            self.validate_t_grZero(self.radius)    # validate type t_grZero
        value = find_attr_value_('roll', node)
        if value is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            value = self.gds_parse_double(value, node, 'roll')
            self.roll = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('subtype', node)
        if value is not None and 'subtype' not in already_processed:
            already_processed.add('subtype')
            self.subtype = value
        value = find_attr_value_('t', node)
        if value is not None and 't' not in already_processed:
            already_processed.add('t')
            value = self.gds_parse_double(value, node, 't')
            self.t = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_objectType(self.type_)    # validate type e_objectType
        value = find_attr_value_('validLength', node)
        if value is not None and 'validLength' not in already_processed:
            already_processed.add('validLength')
            value = self.gds_parse_double(value, node, 'validLength')
            self.validLength = value
            self.validate_t_grEqZero(self.validLength)    # validate type t_grEqZero
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
        value = find_attr_value_('zOffset', node)
        if value is not None and 'zOffset' not in already_processed:
            already_processed.add('zOffset')
            value = self.gds_parse_double(value, node, 'zOffset')
            self.zOffset = value
        super(t_road_objects_object, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'repeat':
            obj_ = t_road_objects_object_repeat.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.repeat.append(obj_)
            obj_.original_tagname_ = 'repeat'
        elif nodeName_ == 'outline':
            obj_ = t_road_objects_object_outlines_outline.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.outline = obj_
            obj_.original_tagname_ = 'outline'
        elif nodeName_ == 'outlines':
            obj_ = t_road_objects_object_outlines.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.outlines = obj_
            obj_.original_tagname_ = 'outlines'
        elif nodeName_ == 'material':
            obj_ = t_road_objects_object_material.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.material.append(obj_)
            obj_.original_tagname_ = 'material'
        elif nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'parkingSpace':
            obj_ = t_road_objects_object_parkingSpace.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parkingSpace = obj_
            obj_.original_tagname_ = 'parkingSpace'
        elif nodeName_ == 'markings':
            obj_ = t_road_objects_object_markings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.markings = obj_
            obj_.original_tagname_ = 'markings'
        elif nodeName_ == 'borders':
            obj_ = t_road_objects_object_borders.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.borders = obj_
            obj_.original_tagname_ = 'borders'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        elif nodeName_ == 'surface':
            obj_ = t_road_objects_object_surface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.surface = obj_
            obj_.original_tagname_ = 'surface'
        super(t_road_objects_object, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects_object


class t_road_objects_bridge(_OpenDriveElement):
    """t_road_objects_bridge -- Bridges are modeled as objects in ASAM OpenDRIVE. Bridges are valid for the whole cross section of a road unless a lane validity record with further restrictions is provided as child element.
    id -- Unique ID within database
    length -- Length of the bridge (in s-direction)
    name -- Name of the bridge. May be chosen freely.
    s -- s-coordinate
    type -- Type of bridge
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, id=None, length=None, name=None, s=None, type_=None, validity=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects_bridge"), self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.length = _cast(float, length)
        self.length_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.s = _cast(float, s)
        self.s_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if validity is None:
            self.validity = []
        else:
            self.validity = validity
        self.validity_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects_bridge)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects_bridge.subclass:
            return t_road_objects_bridge.subclass(*args_, **kwargs_)
        else:
            return t_road_objects_bridge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_t_grEqZero(self, value):
        # Validate type t_grEqZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_grEqZero' % {"value": value, "lineno": lineno} )
                result = False
    def validate_e_bridgeType(self, value):
        # Validate type e_bridgeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['concrete', 'steel', 'brick', 'wood']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on e_bridgeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.validity or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_objects_bridge, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_bridge', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects_bridge')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects_bridge':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_bridge')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects_bridge', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects_bridge'):
        super(t_road_objects_bridge, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects_bridge')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.s is not None and 's' not in already_processed:
            already_processed.add('s')
            outfile.write(' s="%s"' % self.gds_format_double(self.s, input_name='s'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects_bridge', fromsubclass_=False, pretty_print=True):
        super(t_road_objects_bridge, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for validity_ in self.validity:
            namespaceprefix_ = self.validity_nsprefix_ + ':' if (UseCapturedNS_ and self.validity_nsprefix_) else ''
            validity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='validity', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            value = self.gds_parse_double(value, node, 'length')
            self.length = value
            self.validate_t_grEqZero(self.length)    # validate type t_grEqZero
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('s', node)
        if value is not None and 's' not in already_processed:
            already_processed.add('s')
            value = self.gds_parse_double(value, node, 's')
            self.s = value
            self.validate_t_grEqZero(self.s)    # validate type t_grEqZero
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_e_bridgeType(self.type_)    # validate type e_bridgeType
        super(t_road_objects_bridge, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validity':
            obj_ = t_road_objects_object_laneValidity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.validity.append(obj_)
            obj_.original_tagname_ = 'validity'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_objects_bridge, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects_bridge


class t_road_objects(_OpenDriveElement):
    """Container for all objects along a road.
    t_road_objects -- Container for all objects along a road.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, object=None, objectReference=None, tunnel=None, bridge=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_road_objects"), self).__init__( **kwargs_)
        if object is None:
            self.object = []
        else:
            self.object = object
        self.object_nsprefix_ = None
        if objectReference is None:
            self.objectReference = []
        else:
            self.objectReference = objectReference
        self.objectReference_nsprefix_ = None
        if tunnel is None:
            self.tunnel = []
        else:
            self.tunnel = tunnel
        self.tunnel_nsprefix_ = None
        if bridge is None:
            self.bridge = []
        else:
            self.bridge = bridge
        self.bridge_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_road_objects)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_road_objects.subclass:
            return t_road_objects.subclass(*args_, **kwargs_)
        else:
            return t_road_objects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.object or
            self.objectReference or
            self.tunnel or
            self.bridge or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_road_objects, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_road_objects')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_road_objects':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_road_objects', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_road_objects'):
        super(t_road_objects, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_road_objects')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_road_objects', fromsubclass_=False, pretty_print=True):
        super(t_road_objects, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_ in self.object:
            namespaceprefix_ = self.object_nsprefix_ + ':' if (UseCapturedNS_ and self.object_nsprefix_) else ''
            object_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object', pretty_print=pretty_print)
        for objectReference_ in self.objectReference:
            namespaceprefix_ = self.objectReference_nsprefix_ + ':' if (UseCapturedNS_ and self.objectReference_nsprefix_) else ''
            objectReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='objectReference', pretty_print=pretty_print)
        for tunnel_ in self.tunnel:
            namespaceprefix_ = self.tunnel_nsprefix_ + ':' if (UseCapturedNS_ and self.tunnel_nsprefix_) else ''
            tunnel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tunnel', pretty_print=pretty_print)
        for bridge_ in self.bridge:
            namespaceprefix_ = self.bridge_nsprefix_ + ':' if (UseCapturedNS_ and self.bridge_nsprefix_) else ''
            bridge_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bridge', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(t_road_objects, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object':
            obj_ = t_road_objects_object.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object.append(obj_)
            obj_.original_tagname_ = 'object'
        elif nodeName_ == 'objectReference':
            obj_ = t_road_objects_objectReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.objectReference.append(obj_)
            obj_.original_tagname_ = 'objectReference'
        elif nodeName_ == 'tunnel':
            obj_ = t_road_objects_tunnel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tunnel.append(obj_)
            obj_.original_tagname_ = 'tunnel'
        elif nodeName_ == 'bridge':
            obj_ = t_road_objects_bridge.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bridge.append(obj_)
            obj_.original_tagname_ = 'bridge'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_road_objects, self)._buildChildren(child_, node, nodeName_, True)
# end class t_road_objects


class t_header_Offset7(_OpenDriveElement):
    """t_header_Offset7 -- To avoid large coordinates, an offset of the whole dataset may be applied using the
    <
    offset
    >
    element. It enables inertial relocation and re-orientation of datasets. The dataset is first translated by @x, @y, and @z. Afterwards, it is rotated by @hdg around the new origin. Rotation around the z-axis should be avoided. In ASAM OpenDRIVE, the offset of a database is represented by the
    <
    offset
    >
    element within the
    <
    header
    >
    element.
    hdg -- Heading offset (rotation around resulting z-axis)
    x -- Inertial x offset
    y -- Inertial y offset
    z -- Inertial z offset
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, hdg=None, x=None, y=None, z=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_header_Offset7"), self).__init__( **kwargs_)
        self.hdg = _cast(float, hdg)
        self.hdg_nsprefix_ = None
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_header_Offset7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_header_Offset7.subclass:
            return t_header_Offset7.subclass(*args_, **kwargs_)
        else:
            return t_header_Offset7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.dataQuality or
            self.include or
            self.userData or
            super(t_header_Offset7, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_Offset7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_header_Offset7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_header_Offset7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header_Offset7')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_header_Offset7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_header_Offset7'):
        super(t_header_Offset7, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header_Offset7')
        if self.hdg is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            outfile.write(' hdg="%s"' % self.gds_format_double(self.hdg, input_name='hdg'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header_Offset7', fromsubclass_=False, pretty_print=True):
        super(t_header_Offset7, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hdg', node)
        if value is not None and 'hdg' not in already_processed:
            already_processed.add('hdg')
            value = self.gds_parse_double(value, node, 'hdg')
            self.hdg = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            value = self.gds_parse_double(value, node, 'x')
            self.x = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            value = self.gds_parse_double(value, node, 'y')
            self.y = value
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            value = self.gds_parse_double(value, node, 'z')
            self.z = value
        super(t_header_Offset7, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_header_Offset7, self)._buildChildren(child_, node, nodeName_, True)
# end class t_header_Offset7


class t_header5(_OpenDriveElement):
    """t_header5 -- The
    <
    header
    >
    element is the very first element within the
    <
    OpenDRIVE
    >
    element.
    date -- Time/date of database creation according to ISO 8601 (preference: YYYY-MM-DDThh:mm:ss)
    east -- Maximum inertial x value
    name -- Database name
    north -- Maximum inertial y value
    revMajor -- Major revision number of OpenDRIVE format
    revMinor -- Minor revision number of OpenDRIVE format; 6 for OpenDrive 1.6
    south -- Minimum inertial y value
    vendor -- Vendor name
    version -- Version of this road network
    west -- Minimum inertial x value
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = _OpenDriveElement
    def __init__(self, date=None, east=None, name=None, north=None, revMajor=1, revMinor=None, south=None, vendor=None, version=None, west=None, geoReference=None, offset=None, dataQuality=None, include=None, userData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("t_header5"), self).__init__( **kwargs_)
        self.date = _cast(None, date)
        self.date_nsprefix_ = None
        self.east = _cast(float, east)
        self.east_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.north = _cast(float, north)
        self.north_nsprefix_ = None
        self.revMajor = _cast(int, revMajor)
        self.revMajor_nsprefix_ = None
        self.revMinor = _cast(int, revMinor)
        self.revMinor_nsprefix_ = None
        self.south = _cast(float, south)
        self.south_nsprefix_ = None
        self.vendor = _cast(None, vendor)
        self.vendor_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.west = _cast(float, west)
        self.west_nsprefix_ = None
        self.geoReference = geoReference
        self.geoReference_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
        if dataQuality is None:
            self.dataQuality = []
        else:
            self.dataQuality = dataQuality
        self.dataQuality_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if userData is None:
            self.userData = []
        else:
            self.userData = userData
        self.userData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, t_header5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if t_header5.subclass:
            return t_header5.subclass(*args_, **kwargs_)
        else:
            return t_header5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def has__content(self):
        if (
            self.geoReference is not None or
            self.offset is not None or
            self.dataQuality or
            self.include or
            self.userData or
            super(t_header5, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('t_header5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 't_header5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header5')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='t_header5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='t_header5'):
        super(t_header5, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='t_header5')
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.date), input_name='date')), ))
        if self.east is not None and 'east' not in already_processed:
            already_processed.add('east')
            outfile.write(' east="%s"' % self.gds_format_double(self.east, input_name='east'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.north is not None and 'north' not in already_processed:
            already_processed.add('north')
            outfile.write(' north="%s"' % self.gds_format_double(self.north, input_name='north'))
        if self.revMajor is not None and 'revMajor' not in already_processed:
            already_processed.add('revMajor')
            outfile.write(' revMajor="%s"' % self.gds_format_integer(self.revMajor, input_name='revMajor'))
        if self.revMinor is not None and 'revMinor' not in already_processed:
            already_processed.add('revMinor')
            outfile.write(' revMinor="%s"' % self.gds_format_integer(self.revMinor, input_name='revMinor'))
        if self.south is not None and 'south' not in already_processed:
            already_processed.add('south')
            outfile.write(' south="%s"' % self.gds_format_double(self.south, input_name='south'))
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vendor), input_name='vendor')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.west is not None and 'west' not in already_processed:
            already_processed.add('west')
            outfile.write(' west="%s"' % self.gds_format_double(self.west, input_name='west'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='t_header5', fromsubclass_=False, pretty_print=True):
        super(t_header5, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.geoReference is not None:
            namespaceprefix_ = self.geoReference_nsprefix_ + ':' if (UseCapturedNS_ and self.geoReference_nsprefix_) else ''
            self.geoReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geoReference', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
        for dataQuality_ in self.dataQuality:
            namespaceprefix_ = self.dataQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQuality_nsprefix_) else ''
            dataQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQuality', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for userData_ in self.userData:
            namespaceprefix_ = self.userData_nsprefix_ + ':' if (UseCapturedNS_ and self.userData_nsprefix_) else ''
            userData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userData', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('east', node)
        if value is not None and 'east' not in already_processed:
            already_processed.add('east')
            value = self.gds_parse_double(value, node, 'east')
            self.east = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('north', node)
        if value is not None and 'north' not in already_processed:
            already_processed.add('north')
            value = self.gds_parse_double(value, node, 'north')
            self.north = value
        value = find_attr_value_('revMajor', node)
        if value is not None and 'revMajor' not in already_processed:
            already_processed.add('revMajor')
            self.revMajor = self.gds_parse_integer(value, node, 'revMajor')
        value = find_attr_value_('revMinor', node)
        if value is not None and 'revMinor' not in already_processed:
            already_processed.add('revMinor')
            self.revMinor = self.gds_parse_integer(value, node, 'revMinor')
        value = find_attr_value_('south', node)
        if value is not None and 'south' not in already_processed:
            already_processed.add('south')
            value = self.gds_parse_double(value, node, 'south')
            self.south = value
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('west', node)
        if value is not None and 'west' not in already_processed:
            already_processed.add('west')
            value = self.gds_parse_double(value, node, 'west')
            self.west = value
        super(t_header5, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'geoReference':
            obj_ = t_header_GeoReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geoReference = obj_
            obj_.original_tagname_ = 'geoReference'
        elif nodeName_ == 'offset':
            obj_ = t_header_Offset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
        elif nodeName_ == 'dataQuality':
            obj_ = t_dataQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQuality.append(obj_)
            obj_.original_tagname_ = 'dataQuality'
        elif nodeName_ == 'include':
            obj_ = t_include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'userData':
            obj_ = t_userData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userData.append(obj_)
            obj_.original_tagname_ = 'userData'
        super(t_header5, self)._buildChildren(child_, node, nodeName_, True)
# end class t_header5


#
# End data representation classes.
#


GDSClassesMapping = {
    '_OpenDriveElement': _OpenDriveElement,
    '_OpenDriveElement': _OpenDriveElement,
    't_controller': t_controller,
    't_controller_control': t_controller_control,
    't_dataQuality': t_dataQuality,
    't_dataQuality': t_dataQuality,
    't_dataQuality_Error': t_dataQuality_Error,
    't_dataQuality_Error': t_dataQuality_Error,
    't_dataQuality_RawData': t_dataQuality_RawData,
    't_dataQuality_RawData': t_dataQuality_RawData,
    't_header': t_header,
    't_header': t_header,
    't_header_GeoReference': t_header_GeoReference,
    't_header_GeoReference': t_header_GeoReference,
    't_header_Offset': t_header_Offset,
    't_header_Offset': t_header_Offset,
    't_include': t_include,
    't_include': t_include,
    't_junction': t_junction,
    't_junctionGroup': t_junctionGroup,
    't_junctionGroup_junctionReference': t_junctionGroup_junctionReference,
    't_junction_connection': t_junction_connection,
    't_junction_connection_laneLink': t_junction_connection_laneLink,
    't_junction_controller': t_junction_controller,
    't_junction_predecessorSuccessor': t_junction_predecessorSuccessor,
    't_junction_priority': t_junction_priority,
    't_junction_surface': t_junction_surface,
    't_junction_surface_CRG': t_junction_surface_CRG,
    't_road': t_road,
    't_road_elevationProfile': t_road_elevationProfile,
    't_road_elevationProfile_elevation': t_road_elevationProfile_elevation,
    't_road_lanes': t_road_lanes,
    't_road_lanes_laneOffset': t_road_lanes_laneOffset,
    't_road_lanes_laneSection': t_road_lanes_laneSection,
    't_road_lanes_laneSection_center': t_road_lanes_laneSection_center,
    't_road_lanes_laneSection_center_lane': t_road_lanes_laneSection_center_lane,
    't_road_lanes_laneSection_lcr_lane_link': t_road_lanes_laneSection_lcr_lane_link,
    't_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor': t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor,
    't_road_lanes_laneSection_lcr_lane_roadMark': t_road_lanes_laneSection_lcr_lane_roadMark,
    't_road_lanes_laneSection_lcr_lane_roadMark_explicit': t_road_lanes_laneSection_lcr_lane_roadMark_explicit,
    't_road_lanes_laneSection_lcr_lane_roadMark_explicit_line': t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line,
    't_road_lanes_laneSection_lcr_lane_roadMark_sway': t_road_lanes_laneSection_lcr_lane_roadMark_sway,
    't_road_lanes_laneSection_lcr_lane_roadMark_type': t_road_lanes_laneSection_lcr_lane_roadMark_type,
    't_road_lanes_laneSection_lcr_lane_roadMark_type_line': t_road_lanes_laneSection_lcr_lane_roadMark_type_line,
    't_road_lanes_laneSection_left': t_road_lanes_laneSection_left,
    't_road_lanes_laneSection_left_lane': t_road_lanes_laneSection_left_lane,
    't_road_lanes_laneSection_lr_lane': t_road_lanes_laneSection_lr_lane,
    't_road_lanes_laneSection_lr_lane_access': t_road_lanes_laneSection_lr_lane_access,
    't_road_lanes_laneSection_lr_lane_border': t_road_lanes_laneSection_lr_lane_border,
    't_road_lanes_laneSection_lr_lane_height': t_road_lanes_laneSection_lr_lane_height,
    't_road_lanes_laneSection_lr_lane_material': t_road_lanes_laneSection_lr_lane_material,
    't_road_lanes_laneSection_lr_lane_rule': t_road_lanes_laneSection_lr_lane_rule,
    't_road_lanes_laneSection_lr_lane_speed': t_road_lanes_laneSection_lr_lane_speed,
    't_road_lanes_laneSection_lr_lane_width': t_road_lanes_laneSection_lr_lane_width,
    't_road_lanes_laneSection_right': t_road_lanes_laneSection_right,
    't_road_lanes_laneSection_right_lane': t_road_lanes_laneSection_right_lane,
    't_road_lateralProfile': t_road_lateralProfile,
    't_road_lateralProfile_shape': t_road_lateralProfile_shape,
    't_road_lateralProfile_superelevation': t_road_lateralProfile_superelevation,
    't_road_link': t_road_link,
    't_road_link_predecessorSuccessor': t_road_link_predecessorSuccessor,
    't_road_objects': t_road_objects,
    't_road_objects_bridge': t_road_objects_bridge,
    't_road_objects_object': t_road_objects_object,
    't_road_objects_objectReference': t_road_objects_objectReference,
    't_road_objects_object_borders': t_road_objects_object_borders,
    't_road_objects_object_borders_border': t_road_objects_object_borders_border,
    't_road_objects_object_laneValidity': t_road_objects_object_laneValidity,
    't_road_objects_object_markings': t_road_objects_object_markings,
    't_road_objects_object_markings_marking': t_road_objects_object_markings_marking,
    't_road_objects_object_markings_marking_cornerReference': t_road_objects_object_markings_marking_cornerReference,
    't_road_objects_object_material': t_road_objects_object_material,
    't_road_objects_object_outlines': t_road_objects_object_outlines,
    't_road_objects_object_outlines_outline': t_road_objects_object_outlines_outline,
    't_road_objects_object_outlines_outline_cornerLocal': t_road_objects_object_outlines_outline_cornerLocal,
    't_road_objects_object_outlines_outline_cornerRoad': t_road_objects_object_outlines_outline_cornerRoad,
    't_road_objects_object_parkingSpace': t_road_objects_object_parkingSpace,
    't_road_objects_object_repeat': t_road_objects_object_repeat,
    't_road_objects_object_surface': t_road_objects_object_surface,
    't_road_objects_object_surface_CRG': t_road_objects_object_surface_CRG,
    't_road_objects_tunnel': t_road_objects_tunnel,
    't_road_planView': t_road_planView,
    't_road_planView_geometry': t_road_planView_geometry,
    't_road_planView_geometry_arc': t_road_planView_geometry_arc,
    't_road_planView_geometry_line': t_road_planView_geometry_line,
    't_road_planView_geometry_paramPoly3': t_road_planView_geometry_paramPoly3,
    't_road_planView_geometry_poly3': t_road_planView_geometry_poly3,
    't_road_planView_geometry_spiral': t_road_planView_geometry_spiral,
    't_road_railroad': t_road_railroad,
    't_road_railroad_switch': t_road_railroad_switch,
    't_road_railroad_switch_mainTrack': t_road_railroad_switch_mainTrack,
    't_road_railroad_switch_partner': t_road_railroad_switch_partner,
    't_road_railroad_switch_sideTrack': t_road_railroad_switch_sideTrack,
    't_road_signals': t_road_signals,
    't_road_signals_signal': t_road_signals_signal,
    't_road_signals_signalReference': t_road_signals_signalReference,
    't_road_signals_signal_dependency': t_road_signals_signal_dependency,
    't_road_signals_signal_positionInertial': t_road_signals_signal_positionInertial,
    't_road_signals_signal_positionRoad': t_road_signals_signal_positionRoad,
    't_road_signals_signal_reference': t_road_signals_signal_reference,
    't_road_surface': t_road_surface,
    't_road_surface_CRG': t_road_surface_CRG,
    't_road_type': t_road_type,
    't_road_type_speed': t_road_type_speed,
    't_station': t_station,
    't_station_platform': t_station_platform,
    't_station_platform_segment': t_station_platform_segment,
    't_userData': t_userData,
    't_userData': t_userData,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = '_OpenDriveElement1'
        rootClass = _OpenDriveElement1
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = '_OpenDriveElement1'
        rootClass = _OpenDriveElement1
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = '_OpenDriveElement1'
        rootClass = _OpenDriveElement1
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = '_OpenDriveElement1'
        rootClass = _OpenDriveElement1
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from opendrive_17 import *\n\n')
        sys.stdout.write('import opendrive_17 as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
    "{None}_OpenDriveElement": "_OpenDriveElement1",
    "{None}e_dataQuality_RawData_PostProcessing": "e_dataQuality_RawData_PostProcessing10",
    "{None}e_dataQuality_RawData_Source": "e_dataQuality_RawData_Source11",
    "{None}e_unit": "e_unit12",
    "{None}e_unitDistance": "e_unitDistance13",
    "{None}e_unitMass": "e_unitMass14",
    "{None}e_unitSlope": "e_unitSlope15",
    "{None}e_unitSpeed": "e_unitSpeed16",
    "{None}t_dataQuality": "t_dataQuality2",
    "{None}t_dataQuality_Error": "t_dataQuality_Error3",
    "{None}t_dataQuality_RawData": "t_dataQuality_RawData4",
    "{None}t_grEqZero": "t_grEqZero17",
    "{None}t_grZero": "t_grZero18",
    "{None}t_header": "t_header5",
    "{None}t_header_GeoReference": "t_header_GeoReference6",
    "{None}t_header_Offset": "t_header_Offset7",
    "{None}t_include": "t_include8",
    "{None}t_userData": "t_userData9",
    "{None}t_yesNo": "t_yesNo19",
    "{None}t_zeroOne": "t_zeroOne20",
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {}

__all__ = [
    "OpenDRIVE",
    "_OpenDriveElement",
    "_OpenDriveElement1",
    "t_controller",
    "t_controller_control",
    "t_dataQuality",
    "t_dataQuality2",
    "t_dataQuality_Error",
    "t_dataQuality_Error3",
    "t_dataQuality_RawData",
    "t_dataQuality_RawData4",
    "t_header",
    "t_header5",
    "t_header_GeoReference",
    "t_header_GeoReference6",
    "t_header_Offset",
    "t_header_Offset7",
    "t_include",
    "t_include8",
    "t_junction",
    "t_junctionGroup",
    "t_junctionGroup_junctionReference",
    "t_junction_connection",
    "t_junction_connection_laneLink",
    "t_junction_controller",
    "t_junction_predecessorSuccessor",
    "t_junction_priority",
    "t_junction_surface",
    "t_junction_surface_CRG",
    "t_road",
    "t_road_elevationProfile",
    "t_road_elevationProfile_elevation",
    "t_road_lanes",
    "t_road_lanes_laneOffset",
    "t_road_lanes_laneSection",
    "t_road_lanes_laneSection_center",
    "t_road_lanes_laneSection_center_lane",
    "t_road_lanes_laneSection_lcr_lane_link",
    "t_road_lanes_laneSection_lcr_lane_link_predecessorSuccessor",
    "t_road_lanes_laneSection_lcr_lane_roadMark",
    "t_road_lanes_laneSection_lcr_lane_roadMark_explicit",
    "t_road_lanes_laneSection_lcr_lane_roadMark_explicit_line",
    "t_road_lanes_laneSection_lcr_lane_roadMark_sway",
    "t_road_lanes_laneSection_lcr_lane_roadMark_type",
    "t_road_lanes_laneSection_lcr_lane_roadMark_type_line",
    "t_road_lanes_laneSection_left",
    "t_road_lanes_laneSection_left_lane",
    "t_road_lanes_laneSection_lr_lane",
    "t_road_lanes_laneSection_lr_lane_access",
    "t_road_lanes_laneSection_lr_lane_border",
    "t_road_lanes_laneSection_lr_lane_height",
    "t_road_lanes_laneSection_lr_lane_material",
    "t_road_lanes_laneSection_lr_lane_rule",
    "t_road_lanes_laneSection_lr_lane_speed",
    "t_road_lanes_laneSection_lr_lane_width",
    "t_road_lanes_laneSection_right",
    "t_road_lanes_laneSection_right_lane",
    "t_road_lateralProfile",
    "t_road_lateralProfile_shape",
    "t_road_lateralProfile_superelevation",
    "t_road_link",
    "t_road_link_predecessorSuccessor",
    "t_road_objects",
    "t_road_objects_bridge",
    "t_road_objects_object",
    "t_road_objects_objectReference",
    "t_road_objects_object_borders",
    "t_road_objects_object_borders_border",
    "t_road_objects_object_laneValidity",
    "t_road_objects_object_markings",
    "t_road_objects_object_markings_marking",
    "t_road_objects_object_markings_marking_cornerReference",
    "t_road_objects_object_material",
    "t_road_objects_object_outlines",
    "t_road_objects_object_outlines_outline",
    "t_road_objects_object_outlines_outline_cornerLocal",
    "t_road_objects_object_outlines_outline_cornerRoad",
    "t_road_objects_object_parkingSpace",
    "t_road_objects_object_repeat",
    "t_road_objects_object_surface",
    "t_road_objects_object_surface_CRG",
    "t_road_objects_tunnel",
    "t_road_planView",
    "t_road_planView_geometry",
    "t_road_planView_geometry_arc",
    "t_road_planView_geometry_line",
    "t_road_planView_geometry_paramPoly3",
    "t_road_planView_geometry_poly3",
    "t_road_planView_geometry_spiral",
    "t_road_railroad",
    "t_road_railroad_switch",
    "t_road_railroad_switch_mainTrack",
    "t_road_railroad_switch_partner",
    "t_road_railroad_switch_sideTrack",
    "t_road_signals",
    "t_road_signals_signal",
    "t_road_signals_signalReference",
    "t_road_signals_signal_dependency",
    "t_road_signals_signal_positionInertial",
    "t_road_signals_signal_positionRoad",
    "t_road_signals_signal_reference",
    "t_road_surface",
    "t_road_surface_CRG",
    "t_road_type",
    "t_road_type_speed",
    "t_station",
    "t_station_platform",
    "t_station_platform_segment",
    "t_userData",
    "t_userData9"
]
